import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers':
    'authorization, x-client-info, apikey, content-type',
};

interface GeneratePlanRequest {
  user_id: string;
  goal_id: string;
  category: string;
  title: string;
  description: string;
  intensity?: 'easy' | 'medium' | 'hard';
  timezone: string; // Legacy field - kept for backward compatibility
  start_date?: string;
  language?: string;
  detailed_plan?: boolean;
  preview_only?: boolean;
  // New device timezone fields
  device_now_iso: string; // Current device time in ISO format with offset
  device_timezone: string; // IANA timezone (e.g., Asia/Jerusalem)
  device_utc_offset_minutes?: number; // UTC offset in minutes (optional for debugging)
  // New customizable plan parameters
  plan_duration_days?: number; // How many days the plan should last (default: 21)
  preferred_time_ranges?: Array<{
    start_hour: number; // 0-23
    end_hour: number; // 0-23
    label: string; // e.g., "◊ë◊ï◊ß◊®", "◊¶◊î◊®◊ô◊ô◊ù", "◊¢◊®◊ë"
  }>; // Up to 3 time ranges
  preferred_days?: number[]; // Days of week (0=Sunday, 1=Monday, etc.) - if empty, all days
}

interface TaskTemplate {
  title: string;
  description: string;
  day_offset: number;
  time_of_day: 'morning' | 'mid_morning' | 'afternoon' | 'evening';
  // Optional precise time (HH:MM) generated by AI
  custom_time?: string;
}

interface RewardTemplate {
  type: 'daily' | 'milestone' | 'completion';
  title: string;
  description: string;
  day_offset?: number;
}

// Generate rewards for the goal
const getSpecificGuidelines = (
  category: string,
  title: string,
  description: string
): string => {
  const titleLower = title.toLowerCase();
  const descLower = description.toLowerCase();

  // Language learning goals
  if (
    titleLower.includes('learn') &&
    (titleLower.includes('language') ||
      titleLower.includes('spanish') ||
      titleLower.includes('french') ||
      titleLower.includes('english'))
  ) {
    return `
      LANGUAGE LEARNING GUIDELINES:
      - Day 1-3: Set up learning tools (apps, books, resources)
      - Day 4-7: Master basic vocabulary and pronunciation
      - Day 8-14: Practice conversations and grammar
      - Day 15-21: Advanced usage and real-world application
      - Include specific apps, websites, or resources
      - Focus on practical communication skills
      - Include speaking, listening, reading, writing practice`;
  }

  // Fitness goals
  if (
    titleLower.includes('fitness') ||
    titleLower.includes('exercise') ||
    titleLower.includes('workout') ||
    titleLower.includes('gym')
  ) {
    return `
      FITNESS GUIDELINES:
      - Day 1-3: Assess current fitness level and create workout plan
      - Day 4-7: Establish consistent workout routine
      - Day 8-14: Increase intensity and add variety
      - Day 15-21: Advanced training and goal achievement
      - Include specific exercises, sets, reps, duration
      - Focus on progressive overload and proper form
      - Include nutrition and recovery planning`;
  }

  // Career goals
  if (
    titleLower.includes('career') ||
    titleLower.includes('job') ||
    titleLower.includes('promotion') ||
    titleLower.includes('skill')
  ) {
    return `
      CAREER GUIDELINES:
      - Day 1-3: Assess current skills and identify gaps
      - Day 4-7: Develop specific skills and knowledge
      - Day 8-14: Build portfolio and network
      - Day 15-21: Apply skills and advance career
      - Include specific courses, certifications, or projects
      - Focus on measurable professional outcomes
      - Include networking and industry engagement`;
  }

  // Business goals
  if (
    titleLower.includes('business') ||
    titleLower.includes('startup') ||
    titleLower.includes('entrepreneur')
  ) {
    return `
      BUSINESS GUIDELINES:
      - Day 1-3: Market research and business plan development
      - Day 4-7: Legal setup and initial operations
      - Day 8-14: Product/service development and testing
      - Day 15-21: Launch and marketing execution
      - Include specific business tools and platforms
      - Focus on revenue generation and customer acquisition
      - Include financial planning and operations`;
  }

  // Health goals
  if (
    titleLower.includes('health') ||
    titleLower.includes('diet') ||
    titleLower.includes('weight') ||
    titleLower.includes('nutrition')
  ) {
    return `
      HEALTH GUIDELINES:
      - Day 1-3: Assess current health status and set targets
      - Day 4-7: Implement nutrition and exercise changes
      - Day 8-14: Establish healthy habits and routines
      - Day 15-21: Optimize and maintain progress
      - Include specific foods, meal plans, or exercises
      - Focus on measurable health improvements
      - Include tracking and monitoring systems`;
  }

  // Default guidelines
  return `
    GENERAL GUIDELINES:
    - Analyze the specific goal requirements and break into actionable steps
    - Include specific tools, resources, or methods needed
    - Focus on measurable progress and concrete outcomes
    - Build from basic to advanced implementation
    - Address potential obstacles and solutions`;
};

const generateRewards = async (
  goalId: string,
  supabase: any,
  category: string,
  title: string,
  tasks: any[],
  intensity: 'easy' | 'medium' | 'hard' = 'easy'
): Promise<any[]> => {
  // Generate personalized rewards based on tasks
  const getPersonalizedRewards = (
    category: string,
    goalTitle: string,
    tasks: any[]
  ): RewardTemplate[] => {
    const rewards: RewardTemplate[] = [];

    // Daily consistency reward (adjusted for intensity)
    const dailyTaskCount =
      intensity === 'easy' ? 3 : intensity === 'medium' ? 6 : 10;
    rewards.push({
      type: 'daily',
      title: 'Daily Champion',
      description: `Complete ${dailyTaskCount} daily "${goalTitle}" tasks to unlock this achievement! Consistency is the key to success.`,
    });

    // Task-specific rewards (every 5 tasks)
    const taskMilestones = [5, 10, 15, 20];
    taskMilestones.forEach((milestone, index) => {
      if (milestone <= tasks.length) {
        rewards.push({
          type: 'milestone',
          title: `${milestone} Tasks Complete!`,
          description: `Incredible! You've completed ${milestone} tasks for "${goalTitle}". You're making real progress!`,
          day_offset: milestone - 1,
        });
      }
    });

    // Weekly consistency rewards
    rewards.push({
      type: 'milestone',
      title: 'Week 1 Consistency',
      description: `Amazing! You've been consistent with "${goalTitle}" for a full week. Your habits are taking root!`,
      day_offset: 6,
    });

    rewards.push({
      type: 'milestone',
      title: 'Week 2 Momentum',
      description: `Outstanding! Two weeks of consistent progress with "${goalTitle}". You're building unstoppable momentum!`,
      day_offset: 13,
    });

    rewards.push({
      type: 'milestone',
      title: 'Week 3 Mastery',
      description: `Incredible! Three weeks of dedication to "${goalTitle}". You've mastered the art of consistency!`,
      day_offset: 20,
    });

    // Points-based rewards (adjusted for intensity)
    const pointsMilestones =
      intensity === 'easy'
        ? [50, 100, 200]
        : intensity === 'medium'
          ? [100, 200, 400]
          : [200, 400, 800];

    pointsMilestones.forEach((points, index) => {
      const titles = ['Master', 'Champion', 'Legend'];
      rewards.push({
        type: 'milestone',
        title: `${points} Points ${titles[index]}`,
        description: `Congratulations! You've earned ${points} points for "${goalTitle}". Your dedication is paying off!`,
        day_offset: undefined,
      });
    });

    // Category-specific completion rewards
    const completionRewards = {
      lifestyle: {
        title: 'Lifestyle Transformation Complete!',
        description: `Congratulations! You've successfully transformed your lifestyle with "${goalTitle}". You've built healthy habits that will last a lifetime!`,
      },
      career: {
        title: 'Professional Growth Achieved!',
        description: `Outstanding! You've completed your "${goalTitle}" journey and advanced your career. Your dedication has paid off!`,
      },
      mindset: {
        title: 'Mental Strength Mastered!',
        description: `Incredible! You've developed mental resilience through "${goalTitle}". You now have the mindset of a champion!`,
      },
      character: {
        title: 'Character Development Complete!',
        description: `Amazing! You've strengthened your character through "${goalTitle}". You've become the person you always wanted to be!`,
      },
      custom: {
        title: 'Personal Goal Achieved!',
        description: `Congratulations! You've successfully completed your "${goalTitle}" journey. You should be incredibly proud of your dedication and growth!`,
      },
    };

    const completionReward =
      completionRewards[category as keyof typeof completionRewards] ||
      completionRewards.custom;
    rewards.push({
      type: 'completion',
      title: completionReward.title,
      description: completionReward.description,
    });

    return rewards;
  };

  const rewards = getPersonalizedRewards(category, title, tasks);

  // Insert rewards into database
  const insertedRewards: any[] = [];
  for (const reward of rewards) {
    const { data: insertedReward, error } = await supabase
      .from('rewards')
      .insert({
        goal_id: goalId,
        type: reward.type,
        title: reward.title,
        description: reward.description,
        day_offset: reward.day_offset,
        unlocked: false,
      })
      .select()
      .single();

    if (error) {
      console.error('Error inserting reward:', error);
    } else {
      insertedRewards.push(insertedReward);
    }
  }

  return insertedRewards;
};

// Device timezone-aware timing function with strict 07:00-23:00 window and user preferences
function computeRunAtDeviceAware(
  dayNumber: number,
  timeOfDay: 'morning' | 'mid_morning' | 'afternoon' | 'evening',
  deviceNowIso: string,
  deviceTimezone: string,
  startDate?: string,
  preferredTimeRanges?: Array<{start_hour: number, end_hour: number, label: string}>,
  preferredDays?: number[]
): { runAt: string; localRunAt: string; startDecision: 'today' | 'tomorrow' } {
  // Parse the device time as local time (not UTC)
  const deviceNow = new Date(deviceNowIso);
  
  // Use user's preferred time ranges if available, otherwise use standard slots
  let targetHour = 8; // Default fallback
  
  if (preferredTimeRanges && preferredTimeRanges.length > 0) {
    // Map timeOfDay to user's preferred ranges
    const timeRangeIndex = timeOfDay === 'morning' ? 0 : 
                          timeOfDay === 'mid_morning' ? 0 : // Use first range for mid_morning
                          timeOfDay === 'afternoon' ? 1 : 2;
    
    if (preferredTimeRanges[timeRangeIndex]) {
      const range = preferredTimeRanges[timeRangeIndex];
      // Use the start hour of the preferred range
      targetHour = range.start_hour;
    }
  } else {
    // Fallback to standard time slots
    const timeSlots = {
      morning: 8,
      mid_morning: 10,
      afternoon: 14,
      evening: 20,
    };
    targetHour = timeSlots[timeOfDay] || 8;
  }
  
  // Calculate target date in device timezone
  const targetDate = new Date(deviceNow);
  if (startDate) {
    // Use provided start date
    const start = new Date(startDate);
    targetDate.setFullYear(start.getFullYear(), start.getMonth(), start.getDate());
  }
  targetDate.setDate(targetDate.getDate() + (dayNumber - 1));
  targetDate.setHours(targetHour, 0, 0, 0);

  // Check if the target day is in user's preferred days
  if (preferredDays && preferredDays.length > 0) {
    const targetDayOfWeek = targetDate.getDay(); // 0=Sunday, 1=Monday, etc.
    if (!preferredDays.includes(targetDayOfWeek)) {
      // Find the next preferred day
      let daysToAdd = 1;
      let maxDaysToCheck = 7; // Prevent infinite loop
      while (daysToAdd <= maxDaysToCheck) {
        const nextDate = new Date(targetDate);
        nextDate.setDate(nextDate.getDate() + daysToAdd);
        const nextDayOfWeek = nextDate.getDay();
        
        if (preferredDays.includes(nextDayOfWeek)) {
          targetDate.setDate(targetDate.getDate() + daysToAdd);
          break;
        }
        daysToAdd++;
      }
    }
  }

  let startDecision: 'today' | 'tomorrow' = 'today';
  let finalLocalTime = targetDate;

  // For day 1, apply smart scheduling logic
  if (dayNumber === 1) {
    const currentHour = deviceNow.getHours();
    const currentMinute = deviceNow.getMinutes();
    
    // Smart decision: if it's after 20:00, recommend starting tomorrow
    // If it's before 20:00, we can start today but only if there are valid slots
    const isAfter8PM = currentHour >= 20;
    
    if (isAfter8PM) {
      // After 8 PM - recommend starting tomorrow at the target time slot
      startDecision = 'tomorrow';
      finalLocalTime = new Date(deviceNow);
      finalLocalTime.setDate(finalLocalTime.getDate() + 1);
      finalLocalTime.setHours(targetHour, 0, 0, 0);
    } else {
      // Before 8 PM - can start today
      if (targetDate <= deviceNow) {
        // Target time has passed, find next available slot today
        const nextSlot = new Date(deviceNow);
        nextSlot.setMinutes(nextSlot.getMinutes() + 15); // 15 minutes from now
        nextSlot.setSeconds(0, 0);
        
        // If next slot is after 23:00, move to tomorrow at the target time slot
        if (nextSlot.getHours() >= 23) {
          startDecision = 'tomorrow';
          finalLocalTime = new Date(deviceNow);
          finalLocalTime.setDate(finalLocalTime.getDate() + 1);
          finalLocalTime.setHours(targetHour, 0, 0, 0);
        } else {
          finalLocalTime = nextSlot;
        }
      } else {
        // Target time is in the future, use it
        finalLocalTime = targetDate;
      }
    }
  } else {
    // For days 2+, always schedule in the future
    // Ensure it's at least tomorrow if it's day 2
    if (dayNumber === 2) {
      const tomorrow = new Date(deviceNow);
      tomorrow.setDate(tomorrow.getDate() + 1);
      tomorrow.setHours(targetHour, 0, 0, 0);
      finalLocalTime = tomorrow;
    } else {
      finalLocalTime = targetDate;
    }
  }

  // Ensure time is within 07:00-23:00 window (device local time)
  const clampedHour = Math.max(7, Math.min(23, finalLocalTime.getHours()));
  finalLocalTime.setHours(clampedHour, finalLocalTime.getMinutes(), 0, 0);

  // Convert to UTC for database storage
  const runAtUtc = finalLocalTime.toISOString();
  
  // Keep local time for UI display
  const localRunAt = finalLocalTime.toISOString();

  return {
    runAt: runAtUtc,
    localRunAt: localRunAt,
    startDecision: startDecision
  };
}

// Helper function to convert AI-provided HH:MM to time_of_day
function convertHHMMToTimeOfDay(hhmm: string): 'morning' | 'mid_morning' | 'afternoon' | 'evening' {
  const [hoursStr] = hhmm.split(':');
  const hours = parseInt(hoursStr, 10);
  
  if (hours < 10) return 'morning';
  if (hours < 13) return 'mid_morning';
  if (hours < 18) return 'afternoon';
  return 'evening';
}

// Build tailored section outline when AI doesn't provide one
function buildTailoredOutline(
  title: string,
  description: string,
  category: string
): Array<{ title: string; description: string }> {
  const shortTitle = (title || '').trim().slice(0, 60);
  const shortDesc = (description || '').trim().slice(0, 140);
  const cat = (category || 'custom').toLowerCase();
  const theme =
    cat === 'career'
      ? 'professional growth'
      : cat === 'mindset'
        ? 'mental strength'
        : cat === 'character'
          ? 'personal excellence'
          : cat === 'lifestyle'
            ? 'healthy habits'
            : 'personal mastery';

  return [
    {
      title: `Week 1 ‚Ä¢ ${shortTitle || 'Foundations'} Foundations`,
      description:
        shortDesc ||
        `Lay the groundwork for ${shortTitle || 'your goal'} with ${theme}, systems, and quick wins.`,
    },
    {
      title: `Week 2 ‚Ä¢ ${shortTitle || 'Goal'} Development`,
      description: `Deepen skills and practice through realistic outputs aligned to "${shortTitle || 'your goal'}".`,
    },
    {
      title: `Week 3 ‚Ä¢ ${shortTitle || 'Goal'} Mastery`,
      description: `Integrate, optimize, and finalize deliverables. Lock in habits for long-term ${theme}.`,
    },
  ];
}

// Build tailored milestones when AI doesn't provide them
function buildTailoredMilestones(totalTasks: number, title: string, planDurationDays: number = 21) {
  const totalWeeks = Math.ceil(planDurationDays / 7);
  const perWeek = Math.max(1, Math.ceil((totalTasks || (planDurationDays * 3)) / totalWeeks));
  const t = (title || 'Your Goal').trim().slice(0, 60);
  
  const milestones: any[] = [];
  for (let week = 1; week <= totalWeeks; week++) {
    let weekTitle, weekDescription;
    
    if (week === 1) {
      weekTitle = `Kickoff ‚Ä¢ ${t} Foundations`;
      weekDescription = 'Establish core systems, momentum, and measurement to start strong.';
    } else if (week === totalWeeks) {
      weekTitle = `Elevate ‚Ä¢ ${t} Mastery`;
      weekDescription = 'Integrate, optimize, and prepare for sustainable long-term success.';
    } else {
      weekTitle = `Build ‚Ä¢ ${t} Skills & Outputs`;
      weekDescription = 'Advance skills with deliberate practice and concrete mid-journey outputs.';
    }
    
    milestones.push({
      week: week,
      title: weekTitle,
      description: weekDescription,
      tasks: perWeek,
    });
  }
  
  return milestones;
}

// AI-powered plan generation with Google Gemini
const generateTasksWithAI = async (
  category: string,
  title: string,
  description: string,
  intensity: 'easy' | 'medium' | 'hard' = 'easy',
  detailedPlan: boolean = false,
  currentTimeIso?: string,
  timezone?: string,
  planDurationDays: number = 21,
  preferredTimeRanges?: Array<{start_hour: number, end_hour: number, label: string}>,
  preferredDays?: number[]
): Promise<{
  tasks: TaskTemplate[];
  iconName: string;
  color: string;
  milestones: any[];
  planOutline?: Array<{ title: string; description: string }>;
  category: string;
  subcategory?: string | null;
  marketingDomain?: string | null;
  deliverables?: any;
}> => {
  console.log('ü§ñ Generating AI-powered plan for:', {
    category,
    title,
    description,
  });

  try {
    const systemPrompt = `
You are Genie, the world's most sophisticated AI personal mentor and success coach. You create life-changing, professional-grade action plans that transform dreams into reality.

üéØ YOUR MISSION: Create the most precise, professional, and transformative 21-day plan that will make users say "This is exactly what I needed!"

INTENSITY LEVELS:
- Easy: 3 tasks per day (Morning, Afternoon, Evening) - ${planDurationDays * 3} total tasks
- Medium: 6 tasks per day (Morning, Mid-Morning, Afternoon, Mid-Afternoon, Evening, Night) - ${planDurationDays * 6} total tasks
- Hard: 10-12 tasks per day (distributed throughout 07:00-23:00) - ${planDurationDays * 10}-${planDurationDays * 12} total tasks

Current intensity level: ${intensity.toUpperCase()}
Plan duration: ${planDurationDays} days

‚è∞ TIME RULES (STRICT):
1) Use 24-hour clock times in HH:MM format only
2) All task times MUST be between 07:00 and 23:00 inclusive - NO EXCEPTIONS
3) For Day 1, consider the user's current time and timezone provided below. Do NOT schedule any Day 1 task in the past. If a suggested time has already passed, choose the next valid future time today; if no valid slot remains today, schedule the task for tomorrow at the earliest valid time (>= 07:00)
4) CRITICAL: If you generate a time outside 07:00-23:00, the system will reject it. Always validate times before including them.
5) STRICT CUT-OFF: If the user's local time (timezone below) is after 20:00, schedule ALL Day 1 tasks for TOMORROW starting at 07:00. If it's before 20:00, you may schedule today but still within 07:00-23:00 and not in the past
6) NO DUPLICATE TIMES: Each task on the same day must have a UNIQUE time. Never schedule multiple tasks at the exact same HH:MM on the same day. Space tasks at least 15 minutes apart.
7) DISTRIBUTE TIMES: Spread tasks throughout the day (morning, afternoon, evening) to avoid clustering at the same time.

üèÜ PROFESSIONAL EXCELLENCE STANDARDS:

PLAN ARCHITECTURE:
1. Week 1 (Days 1-7): Foundation & Mastery Setup
   - Establish unshakeable foundations
   - Build core competencies and systems
   - Create momentum through quick wins
   - Set up tracking and measurement systems

2. Week 2 (Days 8-14): Skill Development & Practice
   - Advanced skill building and refinement
   - Real-world application and testing
   - Problem-solving and adaptation
   - Building expertise and confidence

3. Week 3 (Days 15-21): Mastery & Transformation
   - Advanced mastery and optimization
   - Leadership and teaching others
   - Innovation and creative application
   - Long-term sustainability planning

TASK QUALITY STANDARDS:
Each task must be:
‚úÖ SPECIFIC: Crystal clear instructions that anyone could follow
‚úÖ ACTIONABLE: Concrete steps with measurable outcomes
‚úÖ PROGRESSIVE: Each task builds upon previous achievements
‚úÖ REALISTIC: Achievable within the allocated time frame
‚úÖ RELEVANT: Directly connected to the goal's success
‚úÖ MOTIVATING: Inspiring and confidence-building
‚úÖ PROFESSIONAL: Industry-standard quality and approach

EXPERT-LEVEL TASK CREATION:
- Use industry best practices and proven methodologies
- Include specific tools, resources, and techniques
- Provide measurable success criteria
- Address potential obstacles with solutions
- Build both skills and mindset
- Create sustainable habits and systems
- Include reflection and learning components
- Ensure long-term impact beyond the 21 days

Choose an appropriate Phosphor icon for this goal:

IMPORTANT: Use ONLY valid Phosphor React Native icon names. The icon name must be in kebab-case format and exist in the phosphor-react-native library.

ICON CATEGORIES (all names are valid Phosphor React Native icons):
- lifestyle: heart, leaf, sun, moon, tree, bicycle, person-simple-run, person-simple-walk, person-simple-bike, music-notes, camera, book, flower, cloud, rainbow, drop, mountains, wave, fire
- career: briefcase, laptop, target, lightbulb, rocket, trophy, medal, book, pencil, calculator, users, handshake, money, bank, building, coins, credit-card, wallet, chart-line, chart-pie, storefront, graduation-cap
- mindset: brain, eye, heart, lightbulb, star, compass, target, shield, lock, key, puzzle-piece, infinity, atom, flask, globe, test-tube, book-open, graduation-cap, fingerprint, eye-closed, password
- character: user-circle, users, handshake, heart, shield, star, medal, trophy, compass, user, user-square, hand-heart, crown, sparkle
- custom: star, heart, lightbulb, target, rocket, trophy, medal, tree, sparkle, crown, infinity, puzzle-piece, bell, chat-circle, chat-text, paper-plane, calendar, clock, map-pin, globe-hemisphere-west, thumbs-up, thumbs-down

CRITICAL: The icon_name field MUST be a valid Phosphor React Native icon name in kebab-case format (e.g., "person-simple-run", "user-circle", "lightbulb"). Do NOT use invalid names like "running" which don't exist in the library.

CATEGORY SELECTION:
- You MUST classify the user's goal into one of the following exact categories:
- Valid categories: ["lifestyle", "career", "mindset", "character", "custom"]

COLOR SELECTION (category -> color mapping):
- You MUST choose the color that matches the selected category EXACTLY from this mapping:
- lifestyle: "green"
- career: "blue"
- mindset: "purple"
- character: "pink"
- custom: "yellow"

SUBCATEGORY (REQUIRED):
- Provide a short, concrete subcategory for the goal (e.g., career: "screenwriting", "frontend", "personal finance"; lifestyle: "sleep", "running").
- Keep it 1-3 words, lowercase.

MARKETING DOMAIN (REQUIRED):
- Provide a concise marketing domain label the goal best fits: one of ["content creation", "productivity", "wellness", "education", "finance", "creative arts", "career growth", "mindset", "lifestyle", "health", "business"]. If none fit exactly, choose the closest.

Context for day 1 timing (use these EXACTLY to compute user's local time and apply the 20:00 cut-off):
- current_time_iso: ${currentTimeIso || ''}
- timezone: ${timezone || ''}

‚è∞ USER'S PREFERRED TIME RANGES (CRITICAL - USE THESE EXACTLY):
${preferredTimeRanges && preferredTimeRanges.length > 0 ? 
  preferredTimeRanges.map((range, index) => {
    const timeLabel = index === 0 ? "Morning" : index === 1 ? "Afternoon" : "Evening";
    return `- ${timeLabel}: ${range.start_hour}:00-${range.end_hour}:00 (User's preference)`;
  }).join('\n') : 
  '- Default: Morning (08:00-12:00), Afternoon (14:00-18:00), Evening (19:00-23:00)'}

üìÖ USER'S PREFERRED DAYS (CRITICAL - RESPECT THESE):
${preferredDays && preferredDays.length > 0 ? 
  `- User prefers: ${preferredDays.map(day => ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][day]).join(', ')}` : 
  '- All days of the week (user has no restrictions)'}

‚è∞ SMART SCHEDULING RULES (MANDATORY):
1) If the user's local time is after 20:00 (8 PM), schedule ALL Day 1 tasks for TOMORROW starting at 07:00
2) If the user's local time is before 20:00, you may schedule Day 1 tasks for TODAY but:
   - No task should be scheduled in the past
   - All tasks must be between 07:00-23:00 in the user's local timezone
   - If a suggested time has passed, choose the next available future time today
   - If no valid slots remain today (after 23:00), move to tomorrow at 07:00
3) For days 2-${planDurationDays}, always schedule in the future using preferred time ranges
4) PREFERRED TIME RANGES (CRITICAL): ${preferredTimeRanges && preferredTimeRanges.length > 0 ? 
   'MUST schedule tasks ONLY within the user\'s preferred time ranges listed above. Do NOT use standard time slots.' : 
   'Use standard time slots (morning, afternoon, evening) since user has no preferences'}
5) PREFERRED DAYS (CRITICAL): ${preferredDays && preferredDays.length > 0 ? 
   'MUST schedule tasks ONLY on the user\'s preferred days listed above. Skip days not in the list.' : 
   'Schedule tasks on all days of the week since user has no restrictions'}
6) DISTRIBUTE TIMES: Spread tasks throughout the day to avoid clustering
7) NO DUPLICATE TIMES: Each task on the same day must have a unique time slot
8) RESPECT USER PREFERENCES: The user has customized their plan - honor their choices exactly

üéØ FINAL OUTPUT REQUIREMENTS:

Return ONLY valid JSON in this exact format:
{
  "category": "one-of:lifestyle|career|mindset|character|custom", // required
  "color": "mapped-color", // required: must match the category->color mapping above
  "icon_name": "chosen-icon-name", // MUST be a valid Phosphor React Native icon name in kebab-case
  "subcategory": "short-subcategory",
  "marketing_domain": "one-of:content creation|productivity|wellness|education|finance|creative arts|career growth|mindset|lifestyle|health|business",
  "milestones": [
    {
      "week": 1,
      "title": "Foundation & Setup",
      "description": "Establishing core habits and building momentum for your journey.",
      "tasks": 21
    },
    {
      "week": 2,
      "title": "Skill Development",
      "description": "Advancing your skills and deepening your commitment to the goal.",
      "tasks": 21
    },
    {
      "week": 3,
      "title": "Mastery & Transformation",
      "description": "Achieving mastery and preparing for long-term success.",
      "tasks": 21
    }
  ],
  "plan_outline": [
    { "title": "Section title tailored to this plan", "description": "What this section covers and why" },
    { "title": "Section title", "description": "Details" }
  ],
  "days": [
    {
      "day": 1,
      "summary": "Day 1 focus",
      "tasks": [
        { "time": "HH:MM", "title": "Task title", "description": "What to do" },
        { "time": "HH:MM", "title": "Task title", "description": "What to do" },
        { "time": "HH:MM", "title": "Task title", "description": "What to do" }
      ]
    }
  ]
}

üèÜ QUALITY ASSURANCE CHECKLIST:
Before finalizing your response, ensure each task meets these standards:

‚úÖ TASK TITLES: Professional, specific, and motivating
‚úÖ DESCRIPTIONS: Detailed, actionable, and measurable
‚úÖ TIME DISTRIBUTION: Well-spaced throughout the day
‚úÖ PROGRESSION: Each day builds upon the previous
‚úÖ REALISM: Achievable within time constraints
‚úÖ RELEVANCE: Directly connected to goal success
‚úÖ MOTIVATION: Inspiring and confidence-building
‚úÖ PROFESSIONALISM: Industry-standard quality

üìä QUANTITY REQUIREMENTS:
- Easy: 3 tasks per day (63 total)
- Medium: 6 tasks per day (126 total) 
- Hard: 10-12 tasks per day (210-252 total)

‚è∞ TIME VALIDATION:
- All times must be between 07:00 and 23:00
- No duplicate times on the same day
- Day 1 times must not be in the past
- Space tasks at least 15 minutes apart

üéØ SUCCESS CRITERIA:
Your plan should be so exceptional that users will:
- Feel confident they can achieve their goal
- Be excited to start each day's tasks
- See clear progress and transformation
- Want to recommend Genie to others
- Feel proud of their journey and results

Create a masterpiece that transforms lives!

üì¶ DELIVERABLES CONTRACT (MANDATORY):
In addition to the plan, you MUST produce concrete deliverables tailored to the user's exact request (domain-agnostic). Return them inside a top-level "deliverables" object in the SAME JSON, alongside "days", "milestones", etc.

Rules:
- Detect the user's intent and domain from the title/description
- Produce high-quality deliverables that directly satisfy the user's explicit asks
- Always include the keys below; use empty arrays when a section is not applicable
- Examples of domains and deliverables (guidance, not mandatory):
  - film/video: chosen topic, synopsis, character bios, scene ideas, script snippets, filming checklist, assets
  - language_learning: vocabulary lists, dialogues, practice scripts, resource links
  - fitness: weekly workout tables, exercise library, form cues
  - business/startup: lean canvas snapshot, ICP profile, messaging bullets, backlog
  - career: portfolio outline, project briefs, interview Q&A bank
  - content_creation: content calendar, post ideas, outlines

Deliverables JSON shape (always include all keys; add domain-specific blocks under "sections"):
{
  "deliverables": {
    "overview": {
      "chosen_topic": "string",
      "rationale": "string",
      "synopsis": "string"
    },
    "sections": [
      {
        "type": "string", // e.g., "characters", "scenes", "scripts", "checklist", "assets", "resources", or domain-specific
        "title": "string",
        "items": [ { "label": "string", "content": "string", "meta": {} } ]
      }
    ]
  }
}

STRICT: The entire response must still be ONE JSON object containing category/color/icon_name/subcategory/marketing_domain/milestones/days AND deliverables as defined above. The examples are illustrative only; adapt to ANY request.
`;

    const userGoalPrompt = `
üéØ GOAL ANALYSIS:
Title: ${title}
Description: ${description}
Category: ${category}

üöÄ CREATE A TRANSFORMATIVE 21-DAY MASTERY PLAN

Your task is to create the most professional, comprehensive, and life-changing 21-day plan tailored EXACTLY to the user's request above. If the user asked for concrete deliverables (e.g., "write scripts", "list characters", "create scenes", "filming plan"), you MUST generate tasks that explicitly produce these deliverables in a realistic sequence.

Your plan must:
- Transform the user's current situation into their desired outcome
- Build genuine expertise and mastery
- Create sustainable habits and systems
- Provide measurable progress and results
- Inspire confidence and motivation throughout the journey

üìã PLAN STRUCTURE REQUIREMENTS:

WEEK 1 (Days 1-7): FOUNDATION & MASTERY SETUP (CONCRETE DELIVERABLES)
- Establish unshakeable foundations and core systems
- Build essential competencies and knowledge base
- Create momentum through strategic quick wins
- Set up tracking, measurement, and accountability systems
- Address mindset and motivation barriers
- Build confidence through early successes

WEEK 2 (Days 8-14): SKILL DEVELOPMENT & PRACTICE (PARTIAL OUTPUTS)
- Advanced skill building and refinement
- Real-world application and practical testing
- Problem-solving and adaptive learning
- Building expertise and professional confidence
- Overcoming challenges and obstacles
- Creating sustainable daily practices

WEEK 3 (Days 15-21): MASTERY & TRANSFORMATION (FINAL OUTPUTS)
- Advanced mastery and optimization techniques
- Leadership and knowledge sharing
- Innovation and creative application
- Long-term sustainability and growth planning
- Goal completion and celebration
- Future vision and next-level planning

üéØ TASK CREATION EXCELLENCE:

Each task must be (MANDATORY):
‚úÖ SPECIFIC: "Research 3 proven strategies for [specific aspect]" not "Learn about the topic"
‚úÖ ACTIONABLE: "Complete a 30-minute practice session using [specific technique]" not "Practice"
‚úÖ PROGRESSIVE: Each task builds upon previous achievements and knowledge
‚úÖ REALISTIC: Achievable within the allocated time frame with clear success criteria
‚úÖ RELEVANT: Directly connected to the goal's success with measurable outcomes
‚úÖ MOTIVATING: Inspiring and confidence-building with clear benefits
‚úÖ PROFESSIONAL: Industry-standard quality, tools, and methodologies

DELIVERABLE ALIGNMENT (CRITICAL):
- Detect the user's explicit asks and ensure the deliverables object includes sections that fulfill them. Do NOT assume a specific domain; adapt the sections and items to the user's request.

EXPERT-LEVEL REQUIREMENTS:
- Include specific tools, resources, apps, or platforms to use
- Provide measurable success criteria and completion standards
- Address potential obstacles with practical solutions
- Build both technical skills and mindset/confidence
- Create sustainable habits that extend beyond 21 days
- Include reflection, learning, and adaptation components
- Ensure long-term impact and continued growth

TECHNICAL SPECIFICATIONS:
- For Medium intensity: Morning, Mid-Morning, Afternoon, Mid-Afternoon, Evening, Night
- For Hard intensity: Distribute tasks throughout 07:00-23:00 with strategic spacing
- Use only 24h HH:MM times within 07:00-23:00 window
- Day 1 times must not be in the past relative to current time and timezone
- Each task must have a unique time slot (no duplicates)
- Space tasks at least 15 minutes apart for proper focus

Remember: This plan will be the user's roadmap to transformation. Make it so good they'll want to share it with others!

DELIVERABLES MUST EXIST:
- Ensure the "deliverables" object is present and populated specifically for the user's intent. Include an "overview" and one or more "sections" whose content directly fulfills what they asked for.
`;

    console.log('üì° Sending request to Gemini API...');
    console.log('üîë API Key exists:', !!Deno.env.get('GOOGLE_AI_API_KEY'));
    console.log(
      'üîë API Key length:',
      Deno.env.get('GOOGLE_AI_API_KEY')?.length || 0
    );

    const response = await fetch(
      'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=' +
        Deno.env.get('GOOGLE_AI_API_KEY'),
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [
            {
              role: 'user',
              parts: [{ text: `${systemPrompt}\n\n${userGoalPrompt}` }],
            },
          ],
        }),
      }
    );

    console.log('üì° Gemini API response status:', response.status);

    if (!response.ok) {
      const errorText = await response.text();
      console.error(`‚ùå AI API error: ${response.status}`, errorText);
      console.error('‚ùå Full error details:', {
        status: response.status,
        statusText: response.statusText,
        errorText,
      });
      throw new Error(`AI API error: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    console.log('AI Response data:', JSON.stringify(data, null, 2));

    if (
      !data.candidates ||
      !data.candidates[0] ||
      !data.candidates[0].content
    ) {
      console.error('Invalid AI response structure:', data);
      throw new Error('Invalid AI response structure');
    }

    const text = data.candidates[0].content.parts[0].text;
    console.log('AI Response text:', text);

    // Parse the JSON response
    const cleanedText = text.replace(/```json\n?|\n?```/g, '').trim();
    console.log('Cleaned AI text:', cleanedText);

    try {
      const planData = JSON.parse(cleanedText);
      console.log('Parsed plan data:', planData);

      // Convert the new format to the expected format
      const tasks: TaskTemplate[] = [];

      if (planData.days && Array.isArray(planData.days)) {
        for (const day of planData.days) {
          if (day.tasks && Array.isArray(day.tasks)) {
            for (const task of day.tasks) {
              // Detect HH:MM and derive a time bucket for greetings; attach custom_time
              const isHHMM =
                typeof task.time === 'string' &&
                /^\d{2}:\d{2}$/.test(task.time);
              let timeBucket:
                | 'morning'
                | 'mid_morning'
                | 'afternoon'
                | 'evening' = 'morning';
              let validTime = task.time;

              if (isHHMM) {
                const hour = parseInt(task.time.slice(0, 2), 10);
                const minute = parseInt(task.time.slice(3, 5), 10);

                // Validate and fix time if outside 07:00-23:00 window
                if (hour < 7) {
                  console.warn(
                    `‚ö†Ô∏è Invalid time ${task.time} - too early, adjusting to 07:00`
                  );
                  validTime = '07:00';
                } else if (hour > 23 || (hour === 23 && minute > 0)) {
                  console.warn(
                    `‚ö†Ô∏è Invalid time ${task.time} - too late, adjusting to 23:00`
                  );
                  validTime = '23:00';
                }

                // Recalculate hour after potential adjustment
                const adjustedHour = parseInt(validTime.slice(0, 2), 10);
                if (adjustedHour < 10) timeBucket = 'morning';
                else if (adjustedHour < 13) timeBucket = 'mid_morning';
                else if (adjustedHour < 18) timeBucket = 'afternoon';
                else timeBucket = 'evening';
              } else {
                const t = String(task.time).toLowerCase();
                if (t.includes('mid') && t.includes('morning'))
                  timeBucket = 'mid_morning';
                else if (t.includes('afternoon')) timeBucket = 'afternoon';
                else if (t.includes('evening')) timeBucket = 'evening';
                else timeBucket = 'morning';
              }

              const entry: any = {
                title: task.title,
                description: task.description,
                day_offset: day.day - 1,
                time_of_day: timeBucket,
              };
              if (isHHMM) entry.custom_time = validTime;
              tasks.push(entry as TaskTemplate);
            }
          }
        }
      }

      console.log('Converted tasks:', tasks.length, 'tasks');

      // Validate that we got tasks from AI
      if (tasks.length === 0) {
        console.warn(`No tasks generated by AI. Falling back to template.`);
        throw new Error(`No tasks generated by AI`);
      }

      console.log(`‚úÖ AI generated ${tasks.length} tasks successfully`);

      // Extract milestones from AI response
      let milestones = planData.milestones || [];
      const planOutline = Array.isArray(planData.plan_outline)
        ? planData.plan_outline
        : buildTailoredOutline(
            title,
            description,
            planData.category || category
          );

      // If no milestones provided, generate fallback milestones
      if (!milestones || milestones.length === 0) {
        milestones = buildTailoredMilestones(tasks.length, title, planDurationDays);
      }

      // Extract deliverables if present and minimally validate shape
      let deliverables: any = planData.deliverables || {
        overview: { chosen_topic: '', rationale: '', synopsis: '' },
        sections: [],
      };

      // Basic normalization to guarantee keys exist
      const ensure = (obj: any, key: string, fallback: any) => {
        if (obj[key] === undefined || obj[key] === null) obj[key] = fallback;
      };
      if (typeof deliverables !== 'object' || Array.isArray(deliverables)) {
        deliverables = {
          overview: { chosen_topic: '', rationale: '', synopsis: '' },
          sections: [],
        };
      }
      ensure(deliverables, 'overview', {
        chosen_topic: '',
        rationale: '',
        synopsis: '',
      });
      ensure(deliverables, 'sections', []);

      // Use the category selected by the user (no AI classification needed)
      const validCategories = [
        'lifestyle',
        'career',
        'mindset',
        'character',
        'custom',
      ] as const;
      
      let aiCategory: (typeof validCategories)[number] = category as (typeof validCategories)[number];
      if (!validCategories.includes(aiCategory)) {
        aiCategory = 'custom'; // Fallback to custom if invalid
      }

      // Map color strictly by category per mapping
      const categoryColorMap: Record<(typeof validCategories)[number], string> =
        {
          lifestyle: 'green',
          career: 'blue',
          mindset: 'purple',
          character: 'pink',
          custom: 'yellow',
        };

      // Select appropriate icon for the user-selected category
      const defaultIconForCategory: Record<
        (typeof validCategories)[number],
        string
      > = {
        lifestyle: 'heart',
        career: 'briefcase',
        mindset: 'brain',
        character: 'star',
        custom: 'target',
      };

      let iconName = defaultIconForCategory[aiCategory];
      
      // If AI provided an icon name, validate it's allowed for this category
      if (planData.icon_name) {
        const validCategoryIcons: Record<
          (typeof validCategories)[number],
          string[]
        > = {
          lifestyle: [
            'heart', 'leaf', 'sun', 'moon', 'tree', 'bicycle',
            'person-simple-run', 'person-simple-walk', 'person-simple-bike',
            'music-notes', 'camera', 'book', 'flower', 'cloud',
            'rainbow', 'drop', 'mountains', 'wave', 'fire',
          ],
          career: [
            'briefcase', 'laptop', 'target', 'lightbulb', 'rocket',
            'trophy', 'medal', 'book', 'pencil', 'calculator',
            'users', 'handshake', 'money', 'bank', 'building',
            'coins', 'credit-card', 'wallet', 'chart-line',
            'chart-pie', 'storefront', 'graduation-cap',
          ],
          mindset: [
            'brain', 'eye', 'heart', 'lightbulb', 'star',
            'compass', 'target', 'shield', 'lock', 'key',
            'puzzle-piece', 'infinity', 'atom', 'flask',
            'globe', 'test-tube', 'book-open', 'graduation-cap',
            'fingerprint', 'eye-closed', 'password',
          ],
          character: [
            'user-circle', 'users', 'handshake', 'heart',
            'shield', 'star', 'medal', 'trophy', 'compass',
            'user', 'user-square', 'hand-heart', 'crown', 'sparkle',
          ],
          custom: [
            'star', 'heart', 'lightbulb', 'target', 'rocket',
            'trophy', 'medal', 'tree', 'sparkle', 'crown',
            'infinity', 'puzzle-piece', 'bell', 'chat-circle',
            'chat-text', 'paper-plane', 'calendar', 'clock',
            'map-pin', 'globe-hemisphere-west', 'thumbs-up', 'thumbs-down',
          ],
        };

        if (validCategoryIcons[aiCategory].includes(planData.icon_name)) {
          iconName = planData.icon_name;
        } else {
          console.warn(
            `‚ö†Ô∏è AI suggested icon "${planData.icon_name}" not allowed for category "${aiCategory}", using default "${defaultIconForCategory[aiCategory]}"`
          );
        }
      }

      // Choose color based on category mapping; ignore AI-provided color if any
      const color = categoryColorMap[aiCategory] || 'yellow';

      console.log(
        `üé® AI selected icon: ${iconName}, category: ${aiCategory}, color: ${color}`
      );

      const subcategory: string | null =
        typeof planData.subcategory === 'string' ? planData.subcategory : null;
      const marketingDomain: string | null =
        typeof planData.marketing_domain === 'string'
          ? planData.marketing_domain
          : null;

      return {
        tasks,
        iconName,
        color,
        milestones,
        planOutline,
        category: aiCategory,
        subcategory,
        marketingDomain,
        deliverables,
      };
    } catch (parseError) {
      console.error('Failed to parse AI response as JSON:', parseError);
      console.error('Raw text:', cleanedText);
      throw parseError;
    }
  } catch (error) {
    console.error('‚ùå AI generation failed, falling back to templates:', error);
    console.error('‚ùå Error type:', typeof error);
    console.error('‚ùå Error message:', error.message);
    console.error('‚ùå Error stack:', error.stack);
    const fallbackTasks = generateTasksForCategory(
      category,
      title,
      description,
      intensity
    );
    const fallbackMilestones = buildTailoredMilestones(
      fallbackTasks.length,
      title
    );
    const fallbackOutline = buildTailoredOutline(title, description, category);

    // Use the category selected by the user (no heuristic classification needed)
    const validCategories = [
      'lifestyle',
      'career',
      'mindset',
      'character',
      'custom',
    ] as const;
    
    let aiCategory: (typeof validCategories)[number] = category as (typeof validCategories)[number];
    if (!validCategories.includes(aiCategory)) {
      aiCategory = 'custom'; // Fallback to custom if invalid
    }

    const categoryColorMap: Record<(typeof validCategories)[number], string> = {
      lifestyle: 'green',
      career: 'blue',
      mindset: 'purple',
      character: 'pink',
      custom: 'yellow',
    };
    const defaultIconForCategory: Record<(typeof validCategories)[number], string> = {
      lifestyle: 'heart',
      career: 'briefcase',
      mindset: 'brain',
      character: 'star',
      custom: 'target',
    };

    return {
      tasks: fallbackTasks,
      iconName: defaultIconForCategory[aiCategory],
      color: categoryColorMap[aiCategory],
      milestones: fallbackMilestones,
      category: aiCategory,
      subcategory: null,
      marketingDomain: null,
      deliverables: {
        overview: { chosen_topic: '', rationale: '', synopsis: '' },
        sections: [],
      },
      planOutline: fallbackOutline,
    }; // Default icon/color; include typing fields
  }
};

// Template-based plan generation (fallback) - generates detailed daily plan based on intensity
const generateTasksForCategory = (
  category: string,
  title: string,
  description: string,
  intensity: 'easy' | 'medium' | 'hard' = 'easy',
  planDurationDays: number = 21
): TaskTemplate[] => {
  const tasks: TaskTemplate[] = [];

  // Determine number of tasks per day based on intensity
  const tasksPerDay =
    intensity === 'easy' ? 3 : intensity === 'medium' ? 6 : 12;

  // Generate tasks per day for the specified duration
  for (let day = 0; day < planDurationDays; day++) {
    const dayNumber = day + 1;
    const weekNumber = Math.ceil(dayNumber / 7);

    // Week 1: Foundation & Awareness
    if (weekNumber === 1) {
      const dayTasks = [
        {
          title: `Day ${dayNumber}: Morning Intention Setting`,
          description: `Spend 10 minutes writing down your daily intention and how it connects to your goal. Visualize your success.`,
          day_offset: day,
          time_of_day: 'morning' as const,
        },
        {
          title: `Day ${dayNumber}: Research & Learning`,
          description: `Spend 20 minutes researching strategies and best practices for your goal. Take notes on key insights.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Progress Documentation`,
          description: `Write down what you accomplished today and how you feel about your progress. Celebrate small wins.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
        {
          title: `Day ${dayNumber}: Mid-Morning Focus`,
          description: `Take a focused 15-minute session to work on your goal. Use this time for concentrated effort.`,
          day_offset: day,
          time_of_day: 'mid_morning' as const,
        },
        {
          title: `Day ${dayNumber}: Mid-Afternoon Break`,
          description: `Take a 10-minute break to reflect on your progress and recharge for the evening session.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Evening Review`,
          description: `Review your day's accomplishments and plan tomorrow's focus areas.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
        {
          title: `Day ${dayNumber}: Early Morning Preparation`,
          description: `Set up your workspace and prepare materials for today's goal work.`,
          day_offset: day,
          time_of_day: 'morning' as const,
        },
        {
          title: `Day ${dayNumber}: Midday Check-in`,
          description: `Check your progress and adjust your approach if needed.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Late Morning Session`,
          description: `Dedicate 20 minutes to focused work on your goal.`,
          day_offset: day,
          time_of_day: 'mid_morning' as const,
        },
        {
          title: `Day ${dayNumber}: Afternoon Deep Work`,
          description: `Engage in 30 minutes of deep, uninterrupted work on your goal.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Evening Reflection`,
          description: `Spend 15 minutes reflecting on today's learnings and insights.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
        {
          title: `Day ${dayNumber}: Night Planning`,
          description: `Plan tomorrow's tasks and set intentions for continued progress.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
      ];

      // Add tasks based on intensity level
      tasks.push(...dayTasks.slice(0, tasksPerDay));
    }
    // Week 2: Skill Building & Practice
    else if (weekNumber === 2) {
      const dayTasks = [
        {
          title: `Day ${dayNumber}: Skill Development`,
          description: `Practice and develop specific skills needed for your goal. Focus on deliberate practice.`,
          day_offset: day,
          time_of_day: 'morning' as const,
        },
        {
          title: `Day ${dayNumber}: Real-world Application`,
          description: `Apply what you've learned in a real-world context. Test your skills in practical situations.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Progress Evaluation`,
          description: `Evaluate your progress and identify what's working well. Adjust your approach if needed.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
        {
          title: `Day ${dayNumber}: Advanced Practice`,
          description: `Engage in advanced practice techniques to deepen your skills.`,
          day_offset: day,
          time_of_day: 'mid_morning' as const,
        },
        {
          title: `Day ${dayNumber}: Skill Integration`,
          description: `Integrate multiple skills together in complex scenarios.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Performance Review`,
          description: `Review your performance and identify areas for improvement.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
        {
          title: `Day ${dayNumber}: Intensive Training`,
          description: `Dedicate 45 minutes to intensive skill development.`,
          day_offset: day,
          time_of_day: 'morning' as const,
        },
        {
          title: `Day ${dayNumber}: Challenge Practice`,
          description: `Challenge yourself with difficult scenarios and problems.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Skill Refinement`,
          description: `Refine and polish your existing skills to perfection.`,
          day_offset: day,
          time_of_day: 'mid_morning' as const,
        },
        {
          title: `Day ${dayNumber}: Complex Application`,
          description: `Apply your skills to complex, multi-step problems.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Mastery Assessment`,
          description: `Assess your current mastery level and set new challenges.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
        {
          title: `Day ${dayNumber}: Skill Expansion`,
          description: `Learn new related skills to expand your capabilities.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
      ];

      // Add tasks based on intensity level
      tasks.push(...dayTasks.slice(0, tasksPerDay));
    }
    // Week 3: Mastery & Integration
    else {
      const dayTasks = [
        {
          title: `Day ${dayNumber}: Advanced Practice`,
          description: `Engage in advanced practice and optimization of your skills. Push your boundaries.`,
          day_offset: day,
          time_of_day: 'morning' as const,
        },
        {
          title: `Day ${dayNumber}: Mastery Demonstration`,
          description: `Demonstrate your mastery of the skills you've developed. Show your progress.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Integration Practice`,
          description: `Integrate your new skills into your daily life and routine. Make it sustainable.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
        {
          title: `Day ${dayNumber}: Expert-Level Challenges`,
          description: `Tackle expert-level challenges to test your mastery.`,
          day_offset: day,
          time_of_day: 'mid_morning' as const,
        },
        {
          title: `Day ${dayNumber}: Teaching Others`,
          description: `Teach someone else what you've learned to solidify your understanding.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Long-term Planning`,
          description: `Plan how to maintain and continue developing your skills long-term.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
        {
          title: `Day ${dayNumber}: Peak Performance`,
          description: `Push yourself to peak performance levels in your goal area.`,
          day_offset: day,
          time_of_day: 'morning' as const,
        },
        {
          title: `Day ${dayNumber}: Innovation & Creativity`,
          description: `Apply your skills in creative and innovative ways.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Leadership Application`,
          description: `Use your skills to lead and inspire others.`,
          day_offset: day,
          time_of_day: 'mid_morning' as const,
        },
        {
          title: `Day ${dayNumber}: Excellence Standards`,
          description: `Set new excellence standards for yourself based on your growth.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Legacy Building`,
          description: `Consider how your skills can create lasting impact and legacy.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
        {
          title: `Day ${dayNumber}: Future Vision`,
          description: `Envision your future with these mastered skills and set new goals.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
      ];

      // Add tasks based on intensity level
      tasks.push(...dayTasks.slice(0, tasksPerDay));
    }
  }

  return tasks;
};

const getTimeForSchedule = (
  date: Date,
  timeOfDay: 'morning' | 'mid_morning' | 'afternoon' | 'evening'
): Date => {
  const scheduledDate = new Date(date);

  switch (timeOfDay) {
    case 'morning':
      scheduledDate.setHours(8, 0, 0, 0);
      break;
    case 'mid_morning':
      scheduledDate.setHours(10, 30, 0, 0);
      break;
    case 'afternoon':
      scheduledDate.setHours(14, 0, 0, 0);
      break;
    case 'evening':
      scheduledDate.setHours(19, 0, 0, 0);
      break;
    default:
      // Fallback for old format
      scheduledDate.setHours(9, 0, 0, 0);
      break;
  }

  return scheduledDate;
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  // Generate request ID for tracking
  const requestId = crypto.randomUUID();
  const startTime = Date.now();

  try {
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    // Parse and validate request
    let requestData: GeneratePlanRequest;
    try {
      requestData = await req.json();
    } catch (parseError) {
      console.error(`[${requestId}] Invalid JSON in request:`, parseError);
      return new Response(
        JSON.stringify({
          success: false,
          error: 'Invalid JSON in request body',
          request_id: requestId,
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 400,
        }
      );
    }

    const {
      user_id,
      goal_id,
      category,
      title,
      description,
      intensity = 'easy',
      timezone, // Legacy field
      start_date,
      language = 'en',
      detailed_plan = false,
      plan_duration_days = 21,
      preferred_time_ranges,
      preferred_days,
    } = requestData;

    // Validate required fields
    const requiredFields = ['user_id', 'goal_id', 'category', 'title', 'description'];
    const missingFields = requiredFields.filter(field => !requestData[field as keyof GeneratePlanRequest]);
    
    if (missingFields.length > 0) {
      console.error(`[${requestId}] Missing required fields:`, missingFields);
      return new Response(
        JSON.stringify({
          success: false,
          error: `Missing required fields: ${missingFields.join(', ')}`,
          request_id: requestId,
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 400,
        }
      );
    }

    // Handle missing device timezone fields with fallback
    let device_now_iso = requestData.device_now_iso;
    let device_timezone = requestData.device_timezone;
    let device_utc_offset_minutes = requestData.device_utc_offset_minutes;

    if (!device_now_iso || !device_timezone) {
      console.warn(`[${requestId}] Missing device timezone fields, using fallback values`);
      const now = new Date();
      device_now_iso = now.toISOString();
      device_timezone = 'UTC'; // Fallback to UTC
      device_utc_offset_minutes = 0;
      
      console.warn(`[${requestId}] Using fallback: device_now_iso=${device_now_iso}, device_timezone=${device_timezone}`);
    }

    // Validate field formats
    const validCategories = ['lifestyle', 'career', 'mindset', 'character', 'goal', 'learning', 'health', 'finance', 'social', 'fitness', 'creativity', 'custom'];
    if (!validCategories.includes(category)) {
      console.error(`[${requestId}] Invalid category:`, category);
      return new Response(
        JSON.stringify({
          success: false,
          error: `Invalid category. Must be one of: ${validCategories.join(', ')}`,
          request_id: requestId,
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 400,
        }
      );
    }

    const validIntensities = ['easy', 'medium', 'hard'];
    if (!validIntensities.includes(intensity)) {
      console.error(`[${requestId}] Invalid intensity:`, intensity);
      return new Response(
        JSON.stringify({
          success: false,
          error: `Invalid intensity. Must be one of: ${validIntensities.join(', ')}`,
          request_id: requestId,
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 400,
        }
      );
    }

    // Validate UUIDs
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    if (!uuidRegex.test(user_id)) {
      console.error(`[${requestId}] Invalid user_id format:`, user_id);
      return new Response(
        JSON.stringify({
          success: false,
          error: 'Invalid user_id format',
          request_id: requestId,
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 400,
        }
      );
    }

    if (!uuidRegex.test(goal_id)) {
      console.error(`[${requestId}] Invalid goal_id format:`, goal_id);
      return new Response(
        JSON.stringify({
          success: false,
          error: 'Invalid goal_id format',
          request_id: requestId,
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 400,
        }
      );
    }

    // Validate device timezone fields
    try {
      const deviceNow = new Date(requestData.device_now_iso);
      if (isNaN(deviceNow.getTime())) {
        throw new Error('Invalid device_now_iso format');
      }
    } catch (timeError) {
      console.error(`[${requestId}] Invalid device_now_iso format:`, requestData.device_now_iso);
      return new Response(
        JSON.stringify({
          success: false,
          error: 'Invalid device_now_iso format. Must be valid ISO string with timezone offset.',
          request_id: requestId,
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 400,
        }
      );
    }

    // Validate IANA timezone format (basic check)
    const ianaTimezoneRegex = /^[A-Za-z_]+\/[A-Za-z_]+$/;
    if (!ianaTimezoneRegex.test(requestData.device_timezone)) {
      console.error(`[${requestId}] Invalid device_timezone format:`, requestData.device_timezone);
      return new Response(
        JSON.stringify({
          success: false,
          error: 'Invalid device_timezone format. Must be IANA timezone (e.g., Asia/Jerusalem).',
          request_id: requestId,
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 400,
        }
      );
    }

    // Verify goal ownership
    const { data: goal, error: goalError } = await supabaseClient
      .from('goals')
      .select('id, user_id, title')
      .eq('id', goal_id)
      .eq('user_id', user_id)
      .single();

    if (goalError || !goal) {
      console.error(`[${requestId}] Goal not found or access denied:`, goalError);
      return new Response(
        JSON.stringify({
          success: false,
          error: 'Goal not found or access denied',
          request_id: requestId,
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 404,
        }
      );
    }

    console.log(`[${requestId}] Plan generation request validated:`, {
      user_id,
      goal_id,
      category,
      title: title.substring(0, 50) + '...',
      intensity,
      device_timezone,
      device_now_iso: device_now_iso.substring(0, 19) + '...',
      start_date,
    });

    // Check if this is a regeneration (goal already has tasks) or new goal creation
    const { data: existingTasks, error: checkTasksError } = await supabaseClient
      .from('goal_tasks')
      .select('id')
      .eq('goal_id', goal_id)
      .limit(1);
    
    if (checkTasksError) {
      console.error(`[${requestId}] Error checking existing tasks:`, checkTasksError);
    }
    
    // Only clean up if this is a regeneration (goal already has tasks)
    if (existingTasks && existingTasks.length > 0) {
      console.log(`[${requestId}] Regenerating plan for existing goal - cleaning up previous data...`);
      
      try {
        // Delete existing tasks, rewards, and notifications for this goal
        const { error: deleteTasksError } = await supabaseClient
          .from('goal_tasks')
          .delete()
          .eq('goal_id', goal_id);
        
        if (deleteTasksError) {
          console.error(`[${requestId}] Error deleting existing tasks:`, deleteTasksError);
          // Continue anyway - this is not critical
        }

        const { error: deleteRewardsError } = await supabaseClient
          .from('rewards')
          .delete()
          .eq('goal_id', goal_id);
        
        if (deleteRewardsError) {
          console.error(`[${requestId}] Error deleting existing rewards:`, deleteRewardsError);
          // Continue anyway - this is not critical
        }

        const { error: deleteNotificationsError } = await supabaseClient
          .from('scheduled_notifications')
          .delete()
          .eq('user_id', user_id)
          .in('type', ['task_reminder', 'milestone_reward', 'completion_reward']);
        
        if (deleteNotificationsError) {
          console.error(`[${requestId}] Error deleting existing notifications:`, deleteNotificationsError);
          // Continue anyway - this is not critical
        }

        console.log(`[${requestId}] Cleanup completed successfully`);
      } catch (cleanupError) {
        console.error(`[${requestId}] Error during cleanup:`, cleanupError);
        // Continue anyway - this is not critical
      }
    } else {
      console.log(`[${requestId}] Creating new plan for goal - no cleanup needed`);
    }

    // Deduct a token server-side (source of truth)
    try {
      const { data: tokenRow } = await supabaseClient
        .from('user_tokens')
        .select('*')
        .eq('user_id', user_id)
        .single();

      if (tokenRow) {
        const currentRemaining = Number(tokenRow.tokens_remaining || 0);
        const shouldDecrement = currentRemaining > 0; // consume manual tokens if present
        const updateData: any = {
          tokens_used: (tokenRow.tokens_used || 0) + 1,
          updated_at: new Date().toISOString(),
        };
        if (shouldDecrement) {
          updateData.tokens_remaining = Math.max(0, currentRemaining - 1);
        }
        await supabaseClient
          .from('user_tokens')
          .update(updateData)
          .eq('user_id', user_id);
      } else {
        await supabaseClient.from('user_tokens').insert({
          user_id,
          tokens_used: 1,
          tokens_remaining: 2,
          total_tokens: 3,
          is_subscribed: false,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        });
      }
    } catch (tokErr) {
      console.warn('‚ö†Ô∏è Token deduction skipped:', tokErr);
    }

    // Generate tasks using AI (with template fallback)
    let aiRunId: string | null = null;
    let taskTemplates: any[] = [];
    let iconName = 'star';
    let color = 'blue';
    let milestones: any[] = [];
    let aiCategory = category;
    let deliverables: any = { overview: { chosen_topic: '', rationale: '', synopsis: '' }, sections: [] };
    let planOutline: any[] = [];

    try {
      // Record AI run start
      const { data: aiRun, error: aiRunError } = await supabaseClient
        .from('ai_runs')
        .insert({
          goal_id,
          status: 'success', // Will update to failed if needed
          provider_model: 'gemini-2.5-flash',
          attempts: 1,
        })
        .select('id')
        .single();

      if (aiRunError) {
        console.error(`[${requestId}] Error creating AI run record:`, aiRunError);
      } else {
        aiRunId = aiRun.id;
      }

      const aiStartTime = Date.now();
      
      const result = await generateTasksWithAI(
        category,
        title,
        description,
        intensity,
        detailed_plan,
        device_now_iso, // Pass the actual device time
        device_timezone, // Pass the actual device timezone
        plan_duration_days,
        preferred_time_ranges,
        preferred_days
      );

      const aiLatency = Date.now() - aiStartTime;

      // Update AI run with success
      if (aiRunId) {
        await supabaseClient
          .from('ai_runs')
          .update({
            status: 'success',
            latency_ms: aiLatency,
            response_size: JSON.stringify(result).length,
          })
          .eq('id', aiRunId);
      }

      taskTemplates = result.tasks;
      iconName = result.iconName;
      color = result.color;
      milestones = result.milestones;
      aiCategory = result.category;
      deliverables = result.deliverables;
      planOutline = result.planOutline || [];

      console.log(`[${requestId}] AI generation successful: ${taskTemplates.length} tasks, ${aiLatency}ms`);

    } catch (aiError) {
      console.error(`[${requestId}] AI generation failed:`, aiError);
      
      // Update AI run with failure
      if (aiRunId) {
        await supabaseClient
          .from('ai_runs')
          .update({
            status: 'failed',
            error_text: aiError.message?.substring(0, 1000) || 'Unknown error',
          })
          .eq('id', aiRunId);
      }

      // Fallback to template generation
      console.log(`[${requestId}] Falling back to template generation...`);
      const fallbackResult = generateTasksForCategory(category, title, description, intensity, plan_duration_days);
      taskTemplates = fallbackResult;
      milestones = buildTailoredMilestones(fallbackResult.length, title, plan_duration_days);
      planOutline = buildTailoredOutline(title, description, category);
      
      // Use default values for fallback
      const categoryColorMap: Record<string, string> = {
        lifestyle: 'green',
        career: 'blue',
        mindset: 'purple',
        character: 'pink',
        custom: 'yellow',
      };
      color = categoryColorMap[category] || 'yellow';
    }

    console.log('üìã Generated tasks:', taskTemplates.length, 'tasks');
    console.log('üé® Selected icon:', iconName);

    // Create scheduled tasks using device timezone-aware timing
    const tasksToInsert: any[] = [];
    const usedTimeSlots = new Map<string, Set<string>>(); // day -> Set of time slots
    let startDecision: 'today' | 'tomorrow' = 'today';
    let firstTaskScheduled = false;

    for (const template of taskTemplates) {
      const dayNumber = template.day_offset + 1; // Convert back to 1-based
      
      // Use AI-provided custom_time if available, otherwise use time_of_day
      let timeOfDay = template.time_of_day;
      if (template.custom_time) {
        timeOfDay = convertHHMMToTimeOfDay(template.custom_time);
      }

      // Calculate run_at using device timezone-aware function
      const timingResult = computeRunAtDeviceAware(
        dayNumber, 
        timeOfDay, 
        device_now_iso, 
        device_timezone, 
        start_date,
        preferred_time_ranges,
        preferred_days
      );

      // Capture start decision from first task and apply it to all day 1 tasks
      if (!firstTaskScheduled) {
        startDecision = timingResult.startDecision;
        firstTaskScheduled = true;
        console.log(`[${requestId}] Start decision: ${startDecision} (current time: ${new Date(device_now_iso).toLocaleTimeString()})`);
      }

      // If start decision is 'tomorrow' and this is day 1, adjust the timing
      if (startDecision === 'tomorrow' && dayNumber === 1) {
        // Force all day 1 tasks to start tomorrow at 07:00 or later
        const tomorrow = new Date(device_now_iso);
        tomorrow.setDate(tomorrow.getDate() + 1);
        tomorrow.setHours(7, 0, 0, 0);
        
        // Use user's preferred time ranges if available
        let targetHour = 8; // Default fallback
        
        if (preferred_time_ranges && preferred_time_ranges.length > 0) {
          const timeRangeIndex = timeOfDay === 'morning' ? 0 : 
                                timeOfDay === 'mid_morning' ? 0 : 
                                timeOfDay === 'afternoon' ? 1 : 2;
          
          if (preferred_time_ranges[timeRangeIndex]) {
            targetHour = preferred_time_ranges[timeRangeIndex].start_hour;
          }
        } else {
          // Fallback to standard time slots
          const timeSlots = {
            morning: 8,
            mid_morning: 10,
            afternoon: 14,
            evening: 20,
          };
          targetHour = timeSlots[timeOfDay] || 8;
        }
        
        tomorrow.setHours(targetHour, 0, 0, 0);
        
        // Check if tomorrow is in user's preferred days
        if (preferred_days && preferred_days.length > 0) {
          const tomorrowDayOfWeek = tomorrow.getDay();
          if (!preferred_days.includes(tomorrowDayOfWeek)) {
            // Find the next preferred day
            let daysToAdd = 1;
            while (daysToAdd <= 7) {
              const nextDate = new Date(tomorrow);
              nextDate.setDate(nextDate.getDate() + daysToAdd);
              const nextDayOfWeek = nextDate.getDay();
              
              if (preferred_days.includes(nextDayOfWeek)) {
                tomorrow.setDate(tomorrow.getDate() + daysToAdd);
                break;
              }
              daysToAdd++;
            }
          }
        }
        
        timingResult.runAt = tomorrow.toISOString();
        timingResult.localRunAt = tomorrow.toISOString();
      }

      let runAt = timingResult.runAt;
      let localRunAt = timingResult.localRunAt;

      // Check for time conflicts and resolve them with day folding
      const scheduledTime = new Date(runAt);
      const dayKey = scheduledTime.toDateString();
      const timeSlot = `${scheduledTime.getHours().toString().padStart(2, '0')}:${scheduledTime.getMinutes().toString().padStart(2, '0')}`;

      if (!usedTimeSlots.has(dayKey)) {
        usedTimeSlots.set(dayKey, new Set());
      }

      const dayTimeSlots = usedTimeSlots.get(dayKey)!;

      // If time slot is already used, find next available slot or fold to next day
      if (dayTimeSlots.has(timeSlot)) {
        console.warn(
          `[${requestId}] Time conflict detected for "${template.title}" at ${timeSlot} on ${dayKey}, finding alternative...`
        );

        let adjustedTime = new Date(scheduledTime);
        let attempts = 0;
        const maxAttempts = 20; // Increased for day folding

        while (dayTimeSlots.has(timeSlot) && attempts < maxAttempts) {
          // Try adding 15 minutes
          adjustedTime.setMinutes(adjustedTime.getMinutes() + 15);

          // If we go past 23:00, fold to next day at 07:00
          if (adjustedTime.getHours() >= 23) {
            adjustedTime.setDate(adjustedTime.getDate() + 1);
            adjustedTime.setHours(7, 0, 0, 0);
            
            // Update day key for next day
            const newDayKey = adjustedTime.toDateString();
            if (!usedTimeSlots.has(newDayKey)) {
              usedTimeSlots.set(newDayKey, new Set());
            }
          }

          // Ensure we don't go below 07:00 (shouldn't happen with this logic, but safety check)
          if (adjustedTime.getHours() < 7) {
            adjustedTime.setHours(7, 0, 0, 0);
          }

          const newTimeSlot = `${adjustedTime.getHours().toString().padStart(2, '0')}:${adjustedTime.getMinutes().toString().padStart(2, '0')}`;
          const newDayKey = adjustedTime.toDateString();
          const newDayTimeSlots = usedTimeSlots.get(newDayKey)!;
          
          if (!newDayTimeSlots.has(newTimeSlot)) {
            runAt = adjustedTime.toISOString();
            localRunAt = adjustedTime.toISOString();
            break;
          }
          attempts++;
        }

        if (attempts >= maxAttempts) {
          console.error(
            `[${requestId}] Could not resolve time conflict for "${template.title}" after ${maxAttempts} attempts`
          );
          // Use original time and let database handle it
        }
      }

      // Mark this time slot as used
      const finalTimeSlot = `${new Date(runAt).getHours().toString().padStart(2, '0')}:${new Date(runAt).getMinutes().toString().padStart(2, '0')}`;
      const finalDayKey = new Date(runAt).toDateString();
      const finalDayTimeSlots = usedTimeSlots.get(finalDayKey)!;
      finalDayTimeSlots.add(finalTimeSlot);

      // Final validation: ensure the task is within 07:00-23:00 window
      const finalScheduledTime = new Date(runAt);
      const finalHour = finalScheduledTime.getHours();
      
      if (finalHour < 7 || finalHour >= 23) {
        console.warn(`[${requestId}] Task "${template.title}" scheduled outside 07:00-23:00 window (${finalHour}:00), adjusting...`);
        // Adjust to nearest valid time
        if (finalHour < 7) {
          finalScheduledTime.setHours(7, 0, 0, 0);
        } else {
          finalScheduledTime.setHours(22, 0, 0, 0); // 22:00 is the latest valid time
        }
        runAt = finalScheduledTime.toISOString();
        localRunAt = finalScheduledTime.toISOString();
      }

      tasksToInsert.push({
        goal_id,
        title: template.title,
        description: template.description,
        run_at: runAt,
        local_run_at: localRunAt, // Store local time for UI display
        intensity: intensity, // Store intensity level with task
        day_offset: template.day_offset, // Store day offset for idempotency
        time_of_day: timeOfDay, // Store time of day for idempotency
      });
    }

    // Insert tasks into database
    const { data: insertedTasks, error: insertError } = await supabaseClient
      .from('goal_tasks')
      .insert(tasksToInsert)
      .select();

    if (insertError) {
      throw insertError;
    }

    // Create personalized notifications for tasks
    const notificationsToInsert = insertedTasks.map((task, index) => {
      const dayNumber = index + 1;
      const weekNumber = Math.ceil(dayNumber / 7);

      const motivationalMessages = {
        week1: [
          `Day ${dayNumber}: Building your foundation! üí™`,
          `Day ${dayNumber}: Every step counts! üöÄ`,
          `Day ${dayNumber}: You're creating new habits! ‚ú®`,
          `Day ${dayNumber}: Progress starts with action! üéØ`,
          `Day ${dayNumber}: Your journey begins now! üåü`,
        ],
        week2: [
          `Day ${dayNumber}: Skills are developing! üí™`,
          `Day ${dayNumber}: You're getting stronger! üöÄ`,
          `Day ${dayNumber}: Consistency is key! ‚ú®`,
          `Day ${dayNumber}: Building momentum! üéØ`,
          `Day ${dayNumber}: You're halfway there! üåü`,
        ],
        week3: [
          `Day ${dayNumber}: Mastery is emerging! üí™`,
          `Day ${dayNumber}: You're almost there! üöÄ`,
          `Day ${dayNumber}: Excellence is becoming natural! ‚ú®`,
          `Day ${dayNumber}: The finish line is near! üéØ`,
          `Day ${dayNumber}: You're transforming! üåü`,
        ],
      };

      const timeBasedGreetings = {
        morning: 'Good morning! ‚òÄÔ∏è',
        mid_morning: 'Good morning! üåÖ',
        afternoon: 'Good afternoon! üå§Ô∏è',
        evening: 'Good evening! üåô',
      };

      const timeOfDay = task.run_at.includes('08:')
        ? 'morning'
        : task.run_at.includes('10:')
          ? 'mid_morning'
          : task.run_at.includes('14:')
            ? 'afternoon'
            : 'evening';

      const weekKey =
        weekNumber === 1 ? 'week1' : weekNumber === 2 ? 'week2' : 'week3';
      const weekMessages = motivationalMessages[weekKey];
      const messageIndex = (dayNumber - 1) % weekMessages.length;

      return {
        user_id,
        task_id: task.id,
        type: 'task_reminder',
        title: `${timeBasedGreetings[timeOfDay]} Day ${dayNumber} - ${task.title}`,
        body: `${weekMessages[messageIndex]}\n\n${task.description}\n\nTap to start your task!`,
        scheduled_for: task.run_at,
      };
    });

    const { error: notificationError } = await supabaseClient
      .from('scheduled_notifications')
      .insert(notificationsToInsert);

    if (notificationError) {
      console.error('Error creating notifications:', notificationError);
      // Don't throw here, as the main task creation succeeded
    }

    // Generate rewards for the goal
    const rewards = await generateRewards(
      goal_id,
      supabaseClient,
      category,
      title,
      taskTemplates,
      intensity
    );

    // Create reward notification templates
    const rewardNotifications = [
      {
        user_id,
        type: 'milestone_reward',
        title: 'üéâ Reward Unlocked!',
        body: 'You reached a milestone! A new reward is waiting for you in the rewards screen',
        scheduled_for: new Date(
          Date.now() + 7 * 24 * 60 * 60 * 1000
        ).toISOString(), // 7 days from now
      },
      {
        user_id,
        type: 'completion_reward',
        title: 'üèÜ Goal Completed!',
        body: 'Congratulations! You completed all tasks and achieved your goal!',
        scheduled_for: new Date(
          Date.now() + 21 * 24 * 60 * 60 * 1000
        ).toISOString(), // 21 days from now
      },
    ];

    await supabaseClient
      .from('scheduled_notifications')
      .insert(rewardNotifications);

    // Update the goal with the AI-selected icon, color, and device timezone info
    await supabaseClient
      .from('goals')
      .update({ 
        icon_name: iconName, 
        color: color, 
        category: aiCategory,
        device_timezone: device_timezone,
        start_decision: startDecision
      })
      .eq('id', goal_id);

    // Send immediate notification for the first task
    if (insertedTasks.length > 0) {
      const firstTask = insertedTasks[0];
      try {
        const notificationResponse = await fetch(
          `${Deno.env.get('SUPABASE_URL')}/functions/v1/send-task-notification`,
          {
            method: 'POST',
            headers: {
              Authorization: `Bearer ${Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              user_id,
              task_id: firstTask.id,
              task_title: firstTask.title,
              task_description: firstTask.description,
              goal_title: title,
            }),
          }
        );

        if (notificationResponse.ok) {
          console.log('‚úÖ Immediate task notification sent');
        } else {
          console.warn('‚ö†Ô∏è Failed to send immediate task notification');
        }
      } catch (error) {
        console.error('‚ùå Error sending immediate task notification:', error);
        // Don't fail the whole process for notification errors
      }
    }

    const totalTime = Date.now() - startTime;
    console.log(`[${requestId}] Plan generation completed successfully in ${totalTime}ms`);

    return new Response(
      JSON.stringify({
        success: true,
        tasks: insertedTasks,
        rewards: rewards,
        icon_name: iconName,
        color: color,
        category: aiCategory,
        milestones: milestones,
        plan_outline: planOutline,
        deliverables: deliverables,
        message: `Generated ${insertedTasks.length} tasks and ${rewards.length} rewards for your goal`,
        request_id: requestId,
        processing_time_ms: totalTime,
        // Device timezone metadata
        start_decision: startDecision,
        device_timezone_used: device_timezone,
        today_window: '07:00-23:00',
        device_utc_offset_minutes: device_utc_offset_minutes,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error) {
    const totalTime = Date.now() - startTime;
    console.error(`[${requestId}] Error generating plan after ${totalTime}ms:`, error);
    
    return new Response(
      JSON.stringify({
        success: false,
        error: error.message || 'Internal server error',
        request_id: requestId,
        processing_time_ms: totalTime,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      }
    );
  }
});
