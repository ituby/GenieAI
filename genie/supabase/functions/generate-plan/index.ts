import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers':
    'authorization, x-client-info, apikey, content-type',
};

interface GeneratePlanRequest {
  user_id: string;
  goal_id: string;
  category: string;
  title: string;
  description: string;
  intensity?: 'easy' | 'medium' | 'hard';
  timezone: string; // Legacy field - kept for backward compatibility
  start_date?: string;
  language?: string;
  detailed_plan?: boolean;
  preview_only?: boolean;
  // New device timezone fields
  device_now_iso: string; // Current device time in ISO format with offset
  device_timezone: string; // IANA timezone (e.g., Asia/Jerusalem)
  device_utc_offset_minutes?: number; // UTC offset in minutes (optional for debugging)
  // New customizable plan parameters
  plan_duration_days?: number; // How many days the plan should last (default: 21)
  preferred_time_ranges?: Array<{
    start_hour: number; // 0-23
    end_hour: number; // 0-23
    label: string; // e.g., "בוקר", "צהריים", "ערב"
  }>; // Up to 3 time ranges
  preferred_days?: number[]; // Days of week (0=Sunday, 1=Monday, etc.) - if empty, all days
}

interface TaskTemplate {
  title: string;
  description: string;
  day_offset: number;
  time_of_day: 'morning' | 'mid_morning' | 'afternoon' | 'evening';
  // Optional precise time (HH:MM) generated by AI
  custom_time?: string;
  // New subtasks structure
  subtasks?: Array<{
    title: string;
    estimated_minutes: number;
    completed?: boolean;
  }>;
  time_allocation_minutes?: number;
  total_subtasks?: number;
  subtasks_completed?: number;
}

interface RewardTemplate {
  type: 'daily' | 'milestone' | 'completion';
  title: string;
  description: string;
  day_offset?: number;
}

// Generate rewards for the goal
const getSpecificGuidelines = (
  category: string,
  title: string,
  description: string
): string => {
  const titleLower = title.toLowerCase();
  const descLower = description.toLowerCase();

  // Language learning goals
  if (
    titleLower.includes('learn') &&
    (titleLower.includes('language') ||
      titleLower.includes('spanish') ||
      titleLower.includes('french') ||
      titleLower.includes('english'))
  ) {
    return `
      LANGUAGE LEARNING GUIDELINES:
      - Day 1-3: Set up learning tools (apps, books, resources)
      - Day 4-7: Master basic vocabulary and pronunciation
      - Day 8-14: Practice conversations and grammar
      - Day 15-21: Advanced usage and real-world application
      - Include specific apps, websites, or resources
      - Focus on practical communication skills
      - Include speaking, listening, reading, writing practice`;
  }

  // Fitness goals
  if (
    titleLower.includes('fitness') ||
    titleLower.includes('exercise') ||
    titleLower.includes('workout') ||
    titleLower.includes('gym')
  ) {
    return `
      FITNESS GUIDELINES:
      - Day 1-3: Assess current fitness level and create workout plan
      - Day 4-7: Establish consistent workout routine
      - Day 8-14: Increase intensity and add variety
      - Day 15-21: Advanced training and goal achievement
      - Include specific exercises, sets, reps, duration
      - Focus on progressive overload and proper form
      - Include nutrition and recovery planning`;
  }

  // Career goals
  if (
    titleLower.includes('career') ||
    titleLower.includes('job') ||
    titleLower.includes('promotion') ||
    titleLower.includes('skill')
  ) {
    return `
      CAREER GUIDELINES:
      - Day 1-3: Assess current skills and identify gaps
      - Day 4-7: Develop specific skills and knowledge
      - Day 8-14: Build portfolio and network
      - Day 15-21: Apply skills and advance career
      - Include specific courses, certifications, or projects
      - Focus on measurable professional outcomes
      - Include networking and industry engagement`;
  }

  // Business goals
  if (
    titleLower.includes('business') ||
    titleLower.includes('startup') ||
    titleLower.includes('entrepreneur')
  ) {
    return `
      BUSINESS GUIDELINES:
      - Day 1-3: Market research and business plan development
      - Day 4-7: Legal setup and initial operations
      - Day 8-14: Product/service development and testing
      - Day 15-21: Launch and marketing execution
      - Include specific business tools and platforms
      - Focus on revenue generation and customer acquisition
      - Include financial planning and operations`;
  }

  // Health goals
  if (
    titleLower.includes('health') ||
    titleLower.includes('diet') ||
    titleLower.includes('weight') ||
    titleLower.includes('nutrition')
  ) {
    return `
      HEALTH GUIDELINES:
      - Day 1-3: Assess current health status and set targets
      - Day 4-7: Implement nutrition and exercise changes
      - Day 8-14: Establish healthy habits and routines
      - Day 15-21: Optimize and maintain progress
      - Include specific foods, meal plans, or exercises
      - Focus on measurable health improvements
      - Include tracking and monitoring systems`;
  }

  // Default guidelines
  return `
    GENERAL GUIDELINES:
    - Analyze the specific goal requirements and break into actionable steps
    - Include specific tools, resources, or methods needed
    - Focus on measurable progress and concrete outcomes
    - Build from basic to advanced implementation
    - Address potential obstacles and solutions`;
};

const generateRewards = async (
  goalId: string,
  supabase: any,
  category: string,
  title: string,
  tasks: any[],
  intensity: 'easy' | 'medium' | 'hard' = 'easy'
): Promise<any[]> => {
  // Generate personalized rewards based on tasks
  const getPersonalizedRewards = (
    category: string,
    goalTitle: string,
    tasks: any[]
  ): RewardTemplate[] => {
    const rewards: RewardTemplate[] = [];

    // Daily consistency reward (adjusted for intensity)
    const dailyTaskCount =
      intensity === 'easy' ? 3 : intensity === 'medium' ? 6 : 10;
    rewards.push({
      type: 'daily',
      title: 'Daily Champion',
      description: `Complete ${dailyTaskCount} daily "${goalTitle}" tasks to unlock this achievement! Consistency is the key to success.`,
    });

    // Task-specific rewards (every 5 tasks)
    const taskMilestones = [5, 10, 15, 20];
    taskMilestones.forEach((milestone, index) => {
      if (milestone <= tasks.length) {
        rewards.push({
          type: 'milestone',
          title: `${milestone} Tasks Complete!`,
          description: `Incredible! You've completed ${milestone} tasks for "${goalTitle}". You're making real progress!`,
          day_offset: milestone - 1,
        });
      }
    });

    // Weekly consistency rewards
    rewards.push({
      type: 'milestone',
      title: 'Week 1 Consistency',
      description: `Amazing! You've been consistent with "${goalTitle}" for a full week. Your habits are taking root!`,
      day_offset: 6,
    });

    rewards.push({
      type: 'milestone',
      title: 'Week 2 Momentum',
      description: `Outstanding! Two weeks of consistent progress with "${goalTitle}". You're building unstoppable momentum!`,
      day_offset: 13,
    });

    rewards.push({
      type: 'milestone',
      title: 'Week 3 Mastery',
      description: `Incredible! Three weeks of dedication to "${goalTitle}". You've mastered the art of consistency!`,
      day_offset: 20,
    });

    // Points-based rewards (adjusted for intensity)
    const pointsMilestones =
      intensity === 'easy'
        ? [50, 100, 200]
        : intensity === 'medium'
          ? [100, 200, 400]
          : [200, 400, 800];

    pointsMilestones.forEach((points, index) => {
      const titles = ['Master', 'Champion', 'Legend'];
      rewards.push({
        type: 'milestone',
        title: `${points} Points ${titles[index]}`,
        description: `Congratulations! You've earned ${points} points for "${goalTitle}". Your dedication is paying off!`,
        day_offset: undefined,
      });
    });

    // Category-specific completion rewards
    const completionRewards = {
      lifestyle: {
        title: 'Lifestyle Transformation Complete!',
        description: `Congratulations! You've successfully transformed your lifestyle with "${goalTitle}". You've built healthy habits that will last a lifetime!`,
      },
      career: {
        title: 'Professional Growth Achieved!',
        description: `Outstanding! You've completed your "${goalTitle}" journey and advanced your career. Your dedication has paid off!`,
      },
      mindset: {
        title: 'Mental Strength Mastered!',
        description: `Incredible! You've developed mental resilience through "${goalTitle}". You now have the mindset of a champion!`,
      },
      character: {
        title: 'Character Development Complete!',
        description: `Amazing! You've strengthened your character through "${goalTitle}". You've become the person you always wanted to be!`,
      },
      custom: {
        title: 'Personal Goal Achieved!',
        description: `Congratulations! You've successfully completed your "${goalTitle}" journey. You should be incredibly proud of your dedication and growth!`,
      },
    };

    const completionReward =
      completionRewards[category as keyof typeof completionRewards] ||
      completionRewards.custom;
    rewards.push({
      type: 'completion',
      title: completionReward.title,
      description: completionReward.description,
    });

    return rewards;
  };

  const rewards = getPersonalizedRewards(category, title, tasks);

  // Insert rewards into database
  const insertedRewards: any[] = [];
  for (const reward of rewards) {
    const { data: insertedReward, error } = await supabase
      .from('rewards')
      .insert({
        goal_id: goalId,
        type: reward.type,
        title: reward.title,
        description: reward.description,
        day_offset: reward.day_offset,
        unlocked: false,
      })
      .select()
      .single();

    if (error) {
      console.error('Error inserting reward:', error);
    } else {
      insertedRewards.push(insertedReward);
    }
  }

  return insertedRewards;
};

// Device timezone-aware timing function with strict 07:00-23:00 window and user preferences
function computeRunAtDeviceAware(
  dayNumber: number,
  timeOfDay: 'morning' | 'mid_morning' | 'afternoon' | 'evening',
  deviceNowIso: string,
  deviceTimezone: string,
  startDate?: string,
  preferredTimeRanges?: Array<{start_hour: number, end_hour: number, label: string}>,
  preferredDays?: number[]
): { runAt: string; localRunAt: string; startDecision: 'today' | 'tomorrow' } {
  // Parse the device time as local time (not UTC)
  const deviceNow = new Date(deviceNowIso);
  
  // Use user's preferred time ranges if available, otherwise use standard slots
  let targetHour = 8; // Default fallback
  
  if (preferredTimeRanges && preferredTimeRanges.length > 0) {
    // Map timeOfDay to user's preferred ranges
    const timeRangeIndex = timeOfDay === 'morning' ? 0 : 
                          timeOfDay === 'mid_morning' ? 0 : // Use first range for mid_morning
                          timeOfDay === 'afternoon' ? 1 : 2;
    
    if (preferredTimeRanges[timeRangeIndex]) {
      const range = preferredTimeRanges[timeRangeIndex];
      // Use the start hour of the preferred range
      targetHour = range.start_hour;
    }
  } else {
    // Fallback to standard time slots
    const timeSlots = {
      morning: 8,
      mid_morning: 10,
      afternoon: 14,
      evening: 20,
    };
    targetHour = timeSlots[timeOfDay] || 8;
  }
  
  // Calculate target date in device timezone
  const targetDate = new Date(deviceNow);
  if (startDate) {
    // Use provided start date
    const start = new Date(startDate);
    targetDate.setFullYear(start.getFullYear(), start.getMonth(), start.getDate());
  }
  targetDate.setDate(targetDate.getDate() + (dayNumber - 1));
  targetDate.setHours(targetHour, 0, 0, 0);

  // Check if the target day is in user's preferred days
  if (preferredDays && preferredDays.length > 0) {
    const targetDayOfWeek = targetDate.getDay(); // 0=Sunday, 1=Monday, etc.
    if (!preferredDays.includes(targetDayOfWeek)) {
      // Find the next preferred day
      let daysToAdd = 1;
      let maxDaysToCheck = 7; // Prevent infinite loop
      while (daysToAdd <= maxDaysToCheck) {
        const nextDate = new Date(targetDate);
        nextDate.setDate(nextDate.getDate() + daysToAdd);
        const nextDayOfWeek = nextDate.getDay();
        
        if (preferredDays.includes(nextDayOfWeek)) {
          targetDate.setDate(targetDate.getDate() + daysToAdd);
          break;
        }
        daysToAdd++;
      }
    }
  }

  let startDecision: 'today' | 'tomorrow' = 'today';
  let finalLocalTime = targetDate;

  // For day 1, apply smart scheduling logic
  if (dayNumber === 1) {
    const currentHour = deviceNow.getHours();
    const currentMinute = deviceNow.getMinutes();
    
    // Smart decision: if it's after 12:00 (noon), recommend starting tomorrow
    // If it's before 12:00, we can start today but only if there are valid slots
    const isAfterNoon = currentHour >= 12;
    
    if (isAfterNoon) {
      // After noon (12:00) - recommend starting tomorrow at the target time slot
      startDecision = 'tomorrow';
      finalLocalTime = new Date(deviceNow);
      finalLocalTime.setDate(finalLocalTime.getDate() + 1);
      finalLocalTime.setHours(targetHour, 0, 0, 0);
    } else {
      // Before noon (12:00) - can start today
      if (targetDate <= deviceNow) {
        // Target time has passed, find next available slot today
        const nextSlot = new Date(deviceNow);
        nextSlot.setMinutes(nextSlot.getMinutes() + 15); // 15 minutes from now
        nextSlot.setSeconds(0, 0);
        
        // If next slot is after 23:00, move to tomorrow at the target time slot
        if (nextSlot.getHours() >= 23) {
          startDecision = 'tomorrow';
          finalLocalTime = new Date(deviceNow);
          finalLocalTime.setDate(finalLocalTime.getDate() + 1);
          finalLocalTime.setHours(targetHour, 0, 0, 0);
        } else {
          finalLocalTime = nextSlot;
        }
      } else {
        // Target time is in the future, use it
        finalLocalTime = targetDate;
      }
    }
  } else {
    // For days 2+, always schedule in the future
    // Ensure it's at least tomorrow if it's day 2
    if (dayNumber === 2) {
      const tomorrow = new Date(deviceNow);
      tomorrow.setDate(tomorrow.getDate() + 1);
      tomorrow.setHours(targetHour, 0, 0, 0);
      finalLocalTime = tomorrow;
    } else {
      finalLocalTime = targetDate;
    }
  }

  // Ensure time is within 07:00-23:00 window (device local time)
  const clampedHour = Math.max(7, Math.min(23, finalLocalTime.getHours()));
  finalLocalTime.setHours(clampedHour, finalLocalTime.getMinutes(), 0, 0);

  // Convert to UTC for database storage
  const runAtUtc = finalLocalTime.toISOString();
  
  // Keep local time for UI display
  const localRunAt = finalLocalTime.toISOString();

  return {
    runAt: runAtUtc,
    localRunAt: localRunAt,
    startDecision: startDecision
  };
}

// Helper function to convert AI-provided HH:MM to time_of_day
function convertHHMMToTimeOfDay(hhmm: string): 'morning' | 'mid_morning' | 'afternoon' | 'evening' {
  const [hoursStr] = hhmm.split(':');
  const hours = parseInt(hoursStr, 10);
  
  if (hours < 10) return 'morning';
  if (hours < 13) return 'mid_morning';
  if (hours < 18) return 'afternoon';
  return 'evening';
}

// Build tailored section outline when AI doesn't provide one
function buildTailoredOutline(
  title: string,
  description: string,
  category: string
): Array<{ title: string; description: string }> {
  const shortTitle = (title || 'Your Goal').trim().slice(0, 50);
  const goalLower = title.toLowerCase();
  const descLower = description.toLowerCase();

  // Try to infer the goal type and create specific outline
  let week1Title, week1Desc, week2Title, week2Desc, week3Title, week3Desc;

  // Startup/Business goals
  if (goalLower.includes('startup') || goalLower.includes('business') || goalLower.includes('company')) {
    week1Title = `Week 1 • ${shortTitle} - Idea & Market Research`;
    week1Desc = `Validate your business idea, research market opportunities, and create your initial business plan for "${shortTitle}".`;
    week2Title = `Week 2 • ${shortTitle} - MVP & Testing`;
    week2Desc = `Build your minimum viable product, test with early users, and iterate based on feedback for "${shortTitle}".`;
    week3Title = `Week 3 • ${shortTitle} - Launch & Growth`;
    week3Desc = `Launch your business, acquire first customers, and establish growth strategies for "${shortTitle}".`;
  }
  // Learning/Education goals
  else if (goalLower.includes('learn') || goalLower.includes('study') || goalLower.includes('course')) {
    const subject = goalLower.replace(/learn|study|course/gi, '').trim();
    week1Title = `Week 1 • ${shortTitle} - Basics & Foundation`;
    week1Desc = `Master the fundamentals and core concepts. Build a strong foundation for "${shortTitle}".`;
    week2Title = `Week 2 • ${shortTitle} - Practice & Application`;
    week2Desc = `Apply your knowledge through hands-on practice and real-world exercises for "${shortTitle}".`;
    week3Title = `Week 3 • ${shortTitle} - Mastery & Fluency`;
    week3Desc = `Achieve proficiency and confidence. Demonstrate your mastery of "${shortTitle}".`;
  }
  // Fitness/Health goals
  else if (goalLower.includes('fitness') || goalLower.includes('workout') || goalLower.includes('exercise') || goalLower.includes('run') || goalLower.includes('weight')) {
    week1Title = `Week 1 • ${shortTitle} - Foundation & Form`;
    week1Desc = `Build your base fitness level, master proper form, and establish consistent habits for "${shortTitle}".`;
    week2Title = `Week 2 • ${shortTitle} - Strength & Endurance`;
    week2Desc = `Increase intensity, build strength and stamina, and push your limits for "${shortTitle}".`;
    week3Title = `Week 3 • ${shortTitle} - Peak Performance`;
    week3Desc = `Maximize your fitness level, achieve your targets, and celebrate your transformation with "${shortTitle}".`;
  }
  // Creative goals (writing, music, art, content creation)
  else if (goalLower.includes('write') || goalLower.includes('create') || goalLower.includes('music') || goalLower.includes('art') || goalLower.includes('content') || goalLower.includes('video') || goalLower.includes('channel')) {
    week1Title = `Week 1 • ${shortTitle} - Planning & Setup`;
    week1Desc = `Plan your creative project, gather resources and tools, and create your content strategy for "${shortTitle}".`;
    week2Title = `Week 2 • ${shortTitle} - Creation & Production`;
    week2Desc = `Produce your content, refine your craft, and develop your unique creative style for "${shortTitle}".`;
    week3Title = `Week 3 • ${shortTitle} - Publishing & Growth`;
    week3Desc = `Launch your work, build your audience, and establish your creative presence with "${shortTitle}".`;
  }
  // Career goals
  else if (goalLower.includes('career') || goalLower.includes('job') || goalLower.includes('promotion') || goalLower.includes('skill')) {
    week1Title = `Week 1 • ${shortTitle} - Skills & Knowledge`;
    week1Desc = `Develop essential skills, expand your knowledge base, and identify growth opportunities for "${shortTitle}".`;
    week2Title = `Week 2 • ${shortTitle} - Portfolio & Network`;
    week2Desc = `Build your professional portfolio, expand your network, and demonstrate your expertise in "${shortTitle}".`;
    week3Title = `Week 3 • ${shortTitle} - Advancement & Results`;
    week3Desc = `Apply for opportunities, showcase your growth, and achieve your career goals with "${shortTitle}".`;
  }
  // Generic fallback (still personalized with goal title)
  else {
    week1Title = `Week 1 • ${shortTitle} - Getting Started`;
    week1Desc = `Build the foundation, establish core habits, and gain momentum toward "${shortTitle}".`;
    week2Title = `Week 2 • ${shortTitle} - Building Skills`;
    week2Desc = `Develop expertise, practice consistently, and overcome challenges in your "${shortTitle}" journey.`;
    week3Title = `Week 3 • ${shortTitle} - Achieving Success`;
    week3Desc = `Master your skills, reach your targets, and celebrate your achievement of "${shortTitle}".`;
  }

  return [
    { title: week1Title, description: week1Desc },
    { title: week2Title, description: week2Desc },
    { title: week3Title, description: week3Desc },
  ];
}

// Build tailored milestones when AI doesn't provide them
function buildTailoredMilestones(totalTasks: number, title: string, planDurationDays: number = 21) {
  const totalWeeks = Math.ceil(planDurationDays / 7);
  const perWeek = Math.max(1, Math.ceil((totalTasks || (planDurationDays * 3)) / totalWeeks));
  const t = (title || 'Your Goal').trim().slice(0, 60);
  
  const milestones: any[] = [];
  for (let week = 1; week <= totalWeeks; week++) {
    let weekTitle, weekDescription;
    
    if (week === 1) {
      weekTitle = `Kickoff • ${t} Foundations`;
      weekDescription = 'Establish core systems, momentum, and measurement to start strong.';
    } else if (week === totalWeeks) {
      weekTitle = `Elevate • ${t} Mastery`;
      weekDescription = 'Integrate, optimize, and prepare for sustainable long-term success.';
    } else {
      weekTitle = `Build • ${t} Skills & Outputs`;
      weekDescription = 'Advance skills with deliberate practice and concrete mid-journey outputs.';
    }
    
    milestones.push({
      week: week,
      title: weekTitle,
      description: weekDescription,
      tasks: perWeek,
    });
  }
  
  return milestones;
}

// AI-powered plan generation with Google Gemini
const generateTasksWithAI = async (
  category: string,
  title: string,
  description: string,
  intensity: 'easy' | 'medium' | 'hard' = 'easy',
  detailedPlan: boolean = false,
  currentTimeIso?: string,
  timezone?: string,
  planDurationDays: number = 21,
  preferredTimeRanges?: Array<{start_hour: number, end_hour: number, label: string}>,
  preferredDays?: number[]
): Promise<{
  tasks: TaskTemplate[];
  iconName: string;
  color: string;
  milestones: any[];
  planOutline?: Array<{ title: string; description: string }>;
  category: string;
  subcategory?: string | null;
  marketingDomain?: string | null;
  deliverables?: any;
  usedModel?: string;
}> => {
  console.log('🤖 Generating AI-powered plan for:', {
    category,
    title,
    description,
  });

  try {
    const systemPrompt = `
You are Genie, the world's most sophisticated AI personal mentor and success coach. You create life-changing, professional-grade action plans that transform dreams into reality.

🎯 YOUR MISSION: Create the most precise, professional, and transformative ${planDurationDays}-day plan that will make users say "This is exactly what I needed!"

⚡ PERFORMANCE REQUIREMENTS:
- Respond FAST and EFFICIENTLY - users are waiting!
- Be CONCISE but COMPLETE - quality over quantity
- Follow the exact structure and requirements below
- Generate EXACTLY the number of tasks required (no approximations!)
- Return valid JSON that matches the schema perfectly

⚠️ CRITICAL USER PREFERENCES - FOLLOW EXACTLY:
==========================================
- Plan duration: ${planDurationDays} days
- Tasks per day: ${preferredTimeRanges && preferredTimeRanges.length > 0 ? 
  `EXACTLY ${preferredTimeRanges.length} tasks per day (NON-NEGOTIABLE)` : 
  '3-6 tasks per day (default)'}
- Preferred days: ${preferredDays && preferredDays.length > 0 ? 
  `ONLY ${preferredDays.map(d => ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'][d]).join(', ')} (${preferredDays.length} days/week)` : 
  'All 7 days of the week'}
- Total working days: ${preferredDays && preferredDays.length > 0 ? 
  `${Math.ceil(planDurationDays / 7) * preferredDays.length}` : 
  `${planDurationDays}`} days
- **TOTAL TASKS REQUIRED: ${preferredTimeRanges && preferredTimeRanges.length > 0 ? 
  `EXACTLY ${(preferredDays && preferredDays.length > 0 ? Math.ceil(planDurationDays / 7) * preferredDays.length : planDurationDays) * preferredTimeRanges.length} tasks` : 
  `${(preferredDays && preferredDays.length > 0 ? Math.ceil(planDurationDays / 7) * preferredDays.length : planDurationDays) * 3}-${(preferredDays && preferredDays.length > 0 ? Math.ceil(planDurationDays / 7) * preferredDays.length : planDurationDays) * 6} tasks`}**

🚨 ABSOLUTE REQUIREMENTS (NO EXCEPTIONS):
1. Generate EXACTLY the number of tasks specified above - not one more, not one less
2. ONLY schedule tasks on the preferred days (skip all other days completely)
3. Create EXACTLY ${preferredTimeRanges && preferredTimeRanges.length > 0 ? preferredTimeRanges.length : '3-6'} tasks per active day
4. Each task MUST have ${preferredTimeRanges && preferredTimeRanges.length > 0 ? '1-6' : '1-6'} subtasks
5. Subtasks MUST be actionable, specific, and include time estimates

EXAMPLE CALCULATION:
${preferredDays && preferredDays.length > 0 ? 
  `- User wants ${preferredDays.length} days/week (${preferredDays.map(d => ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][d]).join(', ')})
- Plan is ${planDurationDays} days = ~${Math.ceil(planDurationDays / 7)} weeks
- Working days = ${Math.ceil(planDurationDays / 7)} weeks × ${preferredDays.length} days = ${Math.ceil(planDurationDays / 7) * preferredDays.length} days
- Tasks per day = ${preferredTimeRanges && preferredTimeRanges.length > 0 ? preferredTimeRanges.length : '3-6'}
- TOTAL = ${Math.ceil(planDurationDays / 7) * preferredDays.length} days × ${preferredTimeRanges && preferredTimeRanges.length > 0 ? preferredTimeRanges.length : '3-6'} tasks = ${preferredTimeRanges && preferredTimeRanges.length > 0 ? (Math.ceil(planDurationDays / 7) * preferredDays.length * preferredTimeRanges.length) : `${Math.ceil(planDurationDays / 7) * preferredDays.length * 3}-${Math.ceil(planDurationDays / 7) * preferredDays.length * 6}`} tasks` :
  `- User wants all 7 days
- Plan is ${planDurationDays} days
- Tasks per day = ${preferredTimeRanges && preferredTimeRanges.length > 0 ? preferredTimeRanges.length : '3-6'}
- TOTAL = ${planDurationDays} days × ${preferredTimeRanges && preferredTimeRanges.length > 0 ? preferredTimeRanges.length : '3-6'} tasks = ${preferredTimeRanges && preferredTimeRanges.length > 0 ? (planDurationDays * preferredTimeRanges.length) : `${planDurationDays * 3}-${planDurationDays * 6}`} tasks`}

🎯 TASK STRUCTURE REQUIREMENTS (CRITICAL):

TITLE FORMAT:
- Clear, actionable title (3-8 words max)
- NO "Day X" or day numbers in the title!
- Focus on the action, not the day (e.g., "Research Marketing Strategies" NOT "Day 1: Research")

DESCRIPTION FORMAT:
- Detailed, informative description (2-4 sentences minimum)
- Explain WHAT to do, WHY it matters, and HOW it connects to the goal
- Make it inspiring and motivating
- **CRITICAL: Address user's specific requests and needs**
- If the user asks for recommendations, resources, or specific guidance - INCLUDE THEM in the description
- If the user mentions specific tools, methods, or preferences - INCORPORATE them into tasks
- Provide concrete examples, tools, and resources when relevant

SUBTASKS (MANDATORY - RICH CONTENT):
- Each task MUST include subtasks array with MINIMUM 2-6 subtasks (never just 1!)
- Each subtask should be a specific, completable action
- Each subtask estimated time: 5-20 minutes
- Total time allocation per task: 20-60 minutes
- Subtasks should break down the main task into clear, logical steps
- **CRITICAL: Make subtasks contextual and valuable**
- If task is "Research X", subtasks should include what to research, where to research, how to document findings
- If task is "Learn Y", subtasks should include specific resources, practice exercises, reflection questions
- If user requests specific help (e.g., "help me write", "recommend tools", "create outline"), subtasks should deliver on that request

🎨 RICH CONTENT GUIDELINES - USER-FOCUSED RESPONSES:
==========================================
Your goal is to be HELPFUL and SPECIFIC. If a user asks for help with something, deliver it!

Examples of rich, contextual content:

EXAMPLE 1 - User wants help writing a script about a historical figure:
Task: "Research Historical Figure Background"
Description: "Deep dive into the life, achievements, and context of [Figure Name]. Understanding their story, motivations, and historical impact will help you create an authentic and compelling script. Focus on finding unique angles and lesser-known facts that will make your script stand out."
Subtasks:
- Read comprehensive biography or watch documentary (20 min)
- Create timeline of major life events and turning points (10 min)
- Note 5-7 defining moments or characteristics (8 min)
- Write personal reflection: What makes this figure interesting to you? (7 min)
- List 3-5 potential dramatic conflicts or story arcs (5 min)

EXAMPLE 2 - User wants to learn programming:
Task: "Set Up Development Environment"
Description: "Install and configure professional development tools. Having the right setup from day one will make coding smoother and help you learn faster. We'll use VS Code (free, industry-standard) with recommended extensions for beginners."
Subtasks:
- Download and install VS Code from code.visualstudio.com (10 min)
- Install Python extension and Prettier formatter (5 min)
- Create your first 'hello_world.py' file and run it (10 min)
- Bookmark Python documentation and W3Schools tutorials (5 min)
- Join r/learnprogramming subreddit for community support (5 min)

EXAMPLE 3 - User wants fitness plan:
Task: "Assess Current Fitness Level"
Description: "Establish your baseline fitness through simple at-home tests. Knowing where you start helps track progress and prevents injury by setting appropriate intensity levels. Take photos and measurements for motivation!"
Subtasks:
- Do max push-ups test (stop before failure) and record (5 min)
- Do plank hold test and record time (3 min)
- Measure and record: weight, waist, chest, arms (7 min)
- Take before photos (front, side, back) in consistent lighting (5 min)
- Set 3 specific, measurable fitness goals for 30 days (10 min)

KEY PRINCIPLES:
✅ BE SPECIFIC: Name actual tools, websites, resources, techniques
✅ BE HELPFUL: Answer the implicit questions in the user's request
✅ BE PRACTICAL: Provide actionable steps, not vague advice
✅ BE INSPIRING: Show users the "why" behind each action
✅ BE COMPLETE: Don't leave users wondering "now what?"

TIME SPACING (CRITICAL):
- Tasks must be spaced at LEAST 30 minutes apart
- If a task takes 30 minutes and starts at 09:00, next task should be at 09:30 or later
- NO overlapping tasks!
- Consider time_allocation_minutes when scheduling

Example structure:
{
  "time": "09:00",
  "title": "Research Marketing Strategies",
  "description": "Explore proven marketing techniques for startups. Understanding these strategies will help you reach your target audience effectively and build a strong brand presence from day one.",
  "subtasks": [
    {"title": "Research 3 successful startup marketing campaigns", "estimated_minutes": 15},
    {"title": "List key takeaways and tactics", "estimated_minutes": 10},
    {"title": "Identify which strategies fit your idea", "estimated_minutes": 10}
  ],
  "time_allocation_minutes": 35
}

⏰ TIME RULES (STRICT):
1) Use 24-hour clock times in HH:MM format only
2) All task times MUST be between 07:00 and 23:00 inclusive - NO EXCEPTIONS
3) For Day 1, consider the user's current time and timezone provided below. Do NOT schedule any Day 1 task in the past. If a suggested time has already passed, choose the next valid future time today; if no valid slot remains today, schedule the task for tomorrow at the earliest valid time (>= 07:00)
4) CRITICAL: If you generate a time outside 07:00-23:00, the system will reject it. Always validate times before including them.
5) STRICT CUT-OFF: If the user's local time (timezone below) is after 12:00 (noon), schedule ALL Day 1 tasks for TOMORROW starting at 07:00. If it's before 12:00, you may schedule today but still within 07:00-23:00 and not in the past
6) NO DUPLICATE TIMES: Each task on the same day must have a UNIQUE time. Never schedule multiple tasks at the exact same HH:MM on the same day. Space tasks at least 15 minutes apart.
7) DISTRIBUTE TIMES: Spread tasks throughout the day (morning, afternoon, evening) to avoid clustering at the same time.

🏆 PROFESSIONAL EXCELLENCE STANDARDS:

PLAN ARCHITECTURE:
1. Week 1 (Days 1-7): Foundation & Mastery Setup
   - Establish unshakeable foundations
   - Build core competencies and systems
   - Create momentum through quick wins
   - Set up tracking and measurement systems

2. Week 2 (Days 8-14): Skill Development & Practice
   - Advanced skill building and refinement
   - Real-world application and testing
   - Problem-solving and adaptation
   - Building expertise and confidence

3. Week 3 (Days 15-21): Mastery & Transformation
   - Advanced mastery and optimization
   - Leadership and teaching others
   - Innovation and creative application
   - Long-term sustainability planning

TASK QUALITY STANDARDS:
Each task must be:
✅ SPECIFIC: Crystal clear instructions that anyone could follow
✅ ACTIONABLE: Concrete steps with measurable outcomes
✅ PROGRESSIVE: Each task builds upon previous achievements
✅ REALISTIC: Achievable within the allocated time frame
✅ RELEVANT: Directly connected to the goal's success
✅ MOTIVATING: Inspiring and confidence-building
✅ PROFESSIONAL: Industry-standard quality and approach

EXPERT-LEVEL TASK CREATION:
- Use industry best practices and proven methodologies
- Include specific tools, resources, and techniques
- Provide measurable success criteria
- Address potential obstacles with solutions
- Build both skills and mindset
- Create sustainable habits and systems
- Include reflection and learning components
- Ensure long-term impact beyond the 21 days

🎨 ICON SELECTION (CRITICAL):

IMPORTANT: Icons are NOT category-specific! The user has already selected their category. Your job is to choose the BEST icon based on the GOAL CONTENT, not the category.

Choose from these valid Phosphor React Native icons (kebab-case format):
- People & Human: user, user-circle, user-square, users, handshake, hand-heart, person-simple-run, person-simple-walk, person-simple-bike, fingerprint, eye, eye-closed
- Objects & Tools: heart, star, target, lightbulb, rocket, trophy, medal, crown, sparkle, compass, shield, key, lock, puzzle-piece, infinity, atom, flask, globe, test-tube
- Business & Career: briefcase, laptop, building, bank, money, coins, credit-card, wallet, chart-line, chart-pie, storefront
- Education: book, book-open, graduation-cap, pencil, calculator
- Nature & Lifestyle: leaf, sun, moon, tree, flower, cloud, rainbow, drop, mountains, wave, fire
- Activities: bicycle, music-notes, camera
- Brain & Mind: brain
- Communication: bell, chat-circle, chat-text, paper-plane, calendar, clock, map-pin, password
- Other: globe-hemisphere-west, thumbs-up, thumbs-down

RULES:
1. Choose based on GOAL CONTENT, not category (e.g., "Learn Guitar" → "music-notes" even if category is "mindset")
2. Icon must be in kebab-case format (e.g., "person-simple-run", NOT "running")
3. Icon must exist in the list above
4. Be creative and match the icon to the specific goal, not just the category

CATEGORY SELECTION:
- You MUST classify the user's goal into one of the following exact categories:
- Valid categories: ["lifestyle", "career", "mindset", "character", "custom"]

COLOR SELECTION (category -> color mapping):
- You MUST choose the color that matches the selected category EXACTLY from this mapping:
- lifestyle: "green"
- career: "blue"
- mindset: "purple"
- character: "pink"
- custom: "yellow"

SUBCATEGORY (REQUIRED):
- Provide a short, concrete subcategory for the goal (e.g., career: "screenwriting", "frontend", "personal finance"; lifestyle: "sleep", "running").
- Keep it 1-3 words, lowercase.

MARKETING DOMAIN (REQUIRED):
- Provide a concise marketing domain label the goal best fits: one of ["content creation", "productivity", "wellness", "education", "finance", "creative arts", "career growth", "mindset", "lifestyle", "health", "business"]. If none fit exactly, choose the closest.

Context for day 1 timing (use these EXACTLY to compute user's local time and apply the 12:00 cut-off):
- current_time_iso: ${currentTimeIso || ''}
- timezone: ${timezone || ''}

⏰ USER'S PREFERRED TIME RANGES (CRITICAL - USE THESE EXACTLY):
${preferredTimeRanges && preferredTimeRanges.length > 0 ? 
  preferredTimeRanges.map((range, index) => {
    const timeLabel = index === 0 ? "Morning" : index === 1 ? "Afternoon" : "Evening";
    return `- ${timeLabel}: ${range.start_hour}:00-${range.end_hour}:00 (User's preference)`;
  }).join('\n') : 
  '- Default: Morning (08:00-12:00), Afternoon (14:00-18:00), Evening (19:00-23:00)'}

📅 USER'S PREFERRED DAYS (CRITICAL - RESPECT THESE):
${preferredDays && preferredDays.length > 0 ? 
  `- User prefers: ${preferredDays.map(day => ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][day]).join(', ')}` : 
  '- All days of the week (user has no restrictions)'}

⏰ SMART SCHEDULING RULES (MANDATORY):
1) If the user's local time is after 12:00 (noon), schedule ALL Day 1 tasks for TOMORROW starting at 07:00
2) If the user's local time is before 12:00 (noon), you may schedule Day 1 tasks for TODAY but:
   - No task should be scheduled in the past
   - All tasks must be between 07:00-23:00 in the user's local timezone
   - If a suggested time has passed, choose the next available future time today
   - If no valid slots remain today (after 23:00), move to tomorrow at 07:00
3) For days 2-${planDurationDays}, always schedule in the future using preferred time ranges
4) PREFERRED TIME RANGES (CRITICAL): ${preferredTimeRanges && preferredTimeRanges.length > 0 ? 
   'MUST schedule tasks ONLY within the user\'s preferred time ranges listed above. Do NOT use standard time slots.' : 
   'Use standard time slots (morning, afternoon, evening) since user has no preferences'}
5) PREFERRED DAYS (CRITICAL): ${preferredDays && preferredDays.length > 0 ? 
   'MUST schedule tasks ONLY on the user\'s preferred days listed above. Skip days not in the list.' : 
   'Schedule tasks on all days of the week since user has no restrictions'}
6) DISTRIBUTE TIMES: Spread tasks throughout the day to avoid clustering
7) NO DUPLICATE TIMES: Each task on the same day must have a unique time slot
8) RESPECT USER PREFERENCES: The user has customized their plan - honor their choices exactly

🎯 PLAN OUTLINE REQUIREMENTS (CRITICAL - USER SEES THIS FOR APPROVAL):

The plan_outline is the FIRST thing users see when approving their plan. It MUST be:
✅ CUSTOMIZED to their specific goal (use goal title and context)
✅ DESCRIPTIVE of what they will actually do each week
✅ INSPIRING and motivating
✅ SPECIFIC, not generic

BAD EXAMPLES (too generic):
❌ "Week 1 • Foundations" - too vague
❌ "Week 2 • Development" - doesn't say what's being developed
❌ "Week 3 • Mastery" - generic, could apply to anything

GOOD EXAMPLES (specific and customized):
✅ For "Create Startup": 
   - Week 1 • Idea Validation & Market Research
   - Week 2 • MVP Development & User Testing  
   - Week 3 • Launch & Customer Acquisition

✅ For "Learn Spanish":
   - Week 1 • Spanish Basics & Daily Vocabulary
   - Week 2 • Conversational Skills & Grammar
   - Week 3 • Fluency & Real-World Practice

✅ For "Run Marathon":
   - Week 1 • Base Building & Running Form
   - Week 2 • Endurance & Speed Training
   - Week 3 • Peak Performance & Race Prep

The user will decide whether to approve based on this outline - make it compelling!

🎯 FINAL OUTPUT REQUIREMENTS:

Return ONLY valid JSON in this exact format:
{
  "category": "one-of:lifestyle|career|mindset|character|custom", // required
  "color": "mapped-color", // required: must match the category->color mapping above
  "icon_name": "chosen-icon-name", // MUST be a valid Phosphor React Native icon name in kebab-case
  "subcategory": "short-subcategory",
  "marketing_domain": "one-of:content creation|productivity|wellness|education|finance|creative arts|career growth|mindset|lifestyle|health|business",
  "milestones": [
    {
      "week": 1,
      "title": "Foundation & Setup",
      "description": "Establishing core habits and building momentum for your journey.",
      "tasks": 21
    },
    {
      "week": 2,
      "title": "Skill Development",
      "description": "Advancing your skills and deepening your commitment to the goal.",
      "tasks": 21
    },
    {
      "week": 3,
      "title": "Mastery & Transformation",
      "description": "Achieving mastery and preparing for long-term success.",
      "tasks": 21
    }
  ],
  "plan_outline": [
    { "title": "Week 1 • [Specific Phase Name]", "description": "Customized description for this goal's first week" },
    { "title": "Week 2 • [Specific Phase Name]", "description": "Customized description for this goal's second week" },
    { "title": "Week 3 • [Specific Phase Name]", "description": "Customized description for this goal's third week" }
  ],
  "days": [
    {
      "day": 1,
      "summary": "Day 1 focus",
      "tasks": [
        { "time": "HH:MM", "title": "Task title", "description": "What to do" },
        { "time": "HH:MM", "title": "Task title", "description": "What to do" },
        { "time": "HH:MM", "title": "Task title", "description": "What to do" }
      ]
    }
  ]
}

🏆 QUALITY ASSURANCE CHECKLIST:
Before finalizing your response, ensure each task meets these standards:

✅ TASK TITLES: Professional, specific, and motivating
✅ DESCRIPTIONS: Detailed, actionable, and measurable
✅ TIME DISTRIBUTION: Well-spaced throughout the day
✅ PROGRESSION: Each day builds upon the previous
✅ REALISM: Achievable within time constraints
✅ RELEVANCE: Directly connected to goal success
✅ MOTIVATION: Inspiring and confidence-building
✅ PROFESSIONALISM: Industry-standard quality

📊 QUANTITY REQUIREMENTS:
- User wants: ${preferredTimeRanges && preferredTimeRanges.length > 0 ? 
  `${preferredTimeRanges.length} tasks per day` : 
  '3-6 tasks per day (default)'}
- Plan duration: ${planDurationDays} days
- Preferred days: ${preferredDays && preferredDays.length > 0 ? 
  `${preferredDays.length} days per week` : 
  'All days'}
- Total working days: ${preferredDays && preferredDays.length > 0 ? 
  `${Math.ceil(planDurationDays / 7) * preferredDays.length}` : 
  `${planDurationDays}`} days
- Total tasks: ${preferredTimeRanges && preferredTimeRanges.length > 0 ? 
  `${(preferredDays && preferredDays.length > 0 ? Math.ceil(planDurationDays / 7) * preferredDays.length : planDurationDays) * preferredTimeRanges.length}` : 
  `${(preferredDays && preferredDays.length > 0 ? Math.ceil(planDurationDays / 7) * preferredDays.length : planDurationDays) * 3}-${(preferredDays && preferredDays.length > 0 ? Math.ceil(planDurationDays / 7) * preferredDays.length : planDurationDays) * 6}`} tasks
- CRITICAL: Generate EXACTLY the number of tasks the user requested, ONLY on preferred days!

⏰ TIME VALIDATION:
- All times must be between 07:00 and 23:00
- NO DUPLICATE TIMES ON THE SAME DAY - each task must have a unique time!
- Day 1 times must not be in the past
- If user has preferred time ranges, schedule tasks within those ranges only
- NEVER schedule 2 tasks at the same time on the same day!
- Space tasks at least 30-60 minutes apart to allow completion of subtasks
- Consider time allocation when spacing tasks (if task needs 30 minutes, next task should be at least 30 minutes later)

🎯 SUCCESS CRITERIA:
Your plan should be so exceptional that users will:
- Feel confident they can achieve their goal
- Be excited to start each day's tasks
- See clear progress and transformation
- Want to recommend Genie to others
- Feel proud of their journey and results

Create a masterpiece that transforms lives!

📦 DELIVERABLES CONTRACT (MANDATORY):
In addition to the plan, you MUST produce concrete deliverables tailored to the user's exact request (domain-agnostic). Return them inside a top-level "deliverables" object in the SAME JSON, alongside "days", "milestones", etc.

Rules:
- Detect the user's intent and domain from the title/description
- Produce high-quality deliverables that directly satisfy the user's explicit asks
- Always include the keys below; use empty arrays when a section is not applicable
- Examples of domains and deliverables (guidance, not mandatory):
  - film/video: chosen topic, synopsis, character bios, scene ideas, script snippets, filming checklist, assets
  - language_learning: vocabulary lists, dialogues, practice scripts, resource links
  - fitness: weekly workout tables, exercise library, form cues
  - business/startup: lean canvas snapshot, ICP profile, messaging bullets, backlog
  - career: portfolio outline, project briefs, interview Q&A bank
  - content_creation: content calendar, post ideas, outlines

Deliverables JSON shape (always include all keys; add domain-specific blocks under "sections"):
{
  "deliverables": {
    "overview": {
      "chosen_topic": "string",
      "rationale": "string",
      "synopsis": "string"
    },
    "sections": [
      {
        "type": "string", // e.g., "characters", "scenes", "scripts", "checklist", "assets", "resources", or domain-specific
        "title": "string",
        "items": [ { "label": "string", "content": "string", "meta": {} } ]
      }
    ]
  }
}

STRICT: The entire response must still be ONE JSON object containing category/color/icon_name/subcategory/marketing_domain/milestones/days AND deliverables as defined above. The examples are illustrative only; adapt to ANY request.
`;

    const userGoalPrompt = `
🎯 GOAL ANALYSIS:
Title: ${title}
Description: ${description}
Category: ${category}

🚀 CREATE A TRANSFORMATIVE 21-DAY MASTERY PLAN

Your task is to create the most professional, comprehensive, and life-changing 21-day plan tailored EXACTLY to the user's request above. If the user asked for concrete deliverables (e.g., "write scripts", "list characters", "create scenes", "filming plan"), you MUST generate tasks that explicitly produce these deliverables in a realistic sequence.

Your plan must:
- Transform the user's current situation into their desired outcome
- Build genuine expertise and mastery
- Create sustainable habits and systems
- Provide measurable progress and results
- Inspire confidence and motivation throughout the journey

📋 PLAN STRUCTURE REQUIREMENTS:

WEEK 1 (Days 1-7): FOUNDATION & MASTERY SETUP (CONCRETE DELIVERABLES)
- Establish unshakeable foundations and core systems
- Build essential competencies and knowledge base
- Create momentum through strategic quick wins
- Set up tracking, measurement, and accountability systems
- Address mindset and motivation barriers
- Build confidence through early successes

WEEK 2 (Days 8-14): SKILL DEVELOPMENT & PRACTICE (PARTIAL OUTPUTS)
- Advanced skill building and refinement
- Real-world application and practical testing
- Problem-solving and adaptive learning
- Building expertise and professional confidence
- Overcoming challenges and obstacles
- Creating sustainable daily practices

WEEK 3 (Days 15-21): MASTERY & TRANSFORMATION (FINAL OUTPUTS)
- Advanced mastery and optimization techniques
- Leadership and knowledge sharing
- Innovation and creative application
- Long-term sustainability and growth planning
- Goal completion and celebration
- Future vision and next-level planning

🎯 TASK CREATION EXCELLENCE:

Each task must be (MANDATORY):
✅ SPECIFIC: "Research 3 proven strategies for [specific aspect]" not "Learn about the topic"
✅ ACTIONABLE: "Complete a 30-minute practice session using [specific technique]" not "Practice"
✅ PROGRESSIVE: Each task builds upon previous achievements and knowledge
✅ REALISTIC: Achievable within the allocated time frame with clear success criteria
✅ RELEVANT: Directly connected to the goal's success with measurable outcomes
✅ MOTIVATING: Inspiring and confidence-building with clear benefits
✅ PROFESSIONAL: Industry-standard quality, tools, and methodologies

DELIVERABLE ALIGNMENT (CRITICAL):
- Detect the user's explicit asks and ensure the deliverables object includes sections that fulfill them. Do NOT assume a specific domain; adapt the sections and items to the user's request.

EXPERT-LEVEL REQUIREMENTS:
- Include specific tools, resources, apps, or platforms to use
- Provide measurable success criteria and completion standards
- Address potential obstacles with practical solutions
- Build both technical skills and mindset/confidence
- Create sustainable habits that extend beyond 21 days
- Include reflection, learning, and adaptation components
- Ensure long-term impact and continued growth

TECHNICAL SPECIFICATIONS:
- For Medium intensity: Morning, Mid-Morning, Afternoon, Mid-Afternoon, Evening, Night
- For Hard intensity: Distribute tasks throughout 07:00-23:00 with strategic spacing
- Use only 24h HH:MM times within 07:00-23:00 window
- Day 1 times must not be in the past relative to current time and timezone
- Each task must have a unique time slot (no duplicates)
- Space tasks at least 15 minutes apart for proper focus

Remember: This plan will be the user's roadmap to transformation. Make it so good they'll want to share it with others!

DELIVERABLES MUST EXIST:
- Ensure the "deliverables" object is present and populated specifically for the user's intent. Include an "overview" and one or more "sections" whose content directly fulfills what they asked for.

🔍 FINAL VALIDATION CHECKLIST - VERIFY BEFORE RETURNING:
==========================================
Before you return your response, VERIFY that you have:

✅ TASK COUNT VERIFICATION:
   □ Generated EXACTLY the required number of tasks (see calculation above)
   □ Each working day has EXACTLY ${preferredTimeRanges && preferredTimeRanges.length > 0 ? preferredTimeRanges.length : '3-6'} tasks
   □ Tasks are ONLY on preferred days (skipped non-preferred days completely)
   
✅ SUBTASKS VERIFICATION:
   □ Every task has 2-6 subtasks (never just 1!)
   □ Each subtask has a title and estimated_minutes
   □ Subtasks are specific, actionable, and relevant
   
✅ CONTENT QUALITY VERIFICATION:
   □ Addressed user's specific requests in descriptions
   □ Included concrete tools, resources, websites when relevant
   □ Provided rich, helpful content (not generic advice)
   □ Made it personal to the user's exact goal
   
✅ TIMING VERIFICATION:
   □ All times are between 07:00-23:00 (STRICT)
   □ Day 1 tasks are not in the past
   □ Tasks use preferred time ranges when specified
   □ No duplicate times on the same day
   □ Tasks spaced at least 15 minutes apart
   
✅ STRUCTURE VERIFICATION:
   □ Valid JSON format that matches the schema
   □ All required fields present (title, description, subtasks, etc.)
   □ plan_outline is specific to the user's goal (not generic)
   □ deliverables object exists and is customized
   
COUNT YOUR TASKS BEFORE SUBMITTING:
Total tasks = ${preferredDays && preferredDays.length > 0 ? 
  `${Math.ceil(planDurationDays / 7)} weeks × ${preferredDays.length} days × ${preferredTimeRanges && preferredTimeRanges.length > 0 ? preferredTimeRanges.length : '3-6'} tasks = ${preferredTimeRanges && preferredTimeRanges.length > 0 ? Math.ceil(planDurationDays / 7) * preferredDays.length * preferredTimeRanges.length : `${Math.ceil(planDurationDays / 7) * preferredDays.length * 3}-${Math.ceil(planDurationDays / 7) * preferredDays.length * 6}`} tasks` :
  `${planDurationDays} days × ${preferredTimeRanges && preferredTimeRanges.length > 0 ? preferredTimeRanges.length : '3-6'} tasks = ${preferredTimeRanges && preferredTimeRanges.length > 0 ? planDurationDays * preferredTimeRanges.length : `${planDurationDays * 3}-${planDurationDays * 6}`} tasks`}

If your task count doesn't match, FIX IT before returning!
`;

    const apiKey = Deno.env.get('GOOGLE_AI_API_KEY');
    console.log('📡 Sending request to Gemini API...');
    console.log('🔑 API Key exists:', !!apiKey);
    console.log('🔑 API Key length:', apiKey?.length || 0);
    
    if (!apiKey || apiKey.length < 10) {
      throw new Error('GOOGLE_AI_API_KEY is missing or invalid');
    }

    // Try with gemini-2.5-flash first, fallback to gemini-1.5-flash if not available
    const models = ['gemini-2.5-flash', 'gemini-1.5-flash'];
    let response: Response | null = null;
    let usedModel = '';
    let lastError = '';

    for (const model of models) {
      console.log(`🤖 Trying model: ${model}`);
      
      try {
        response = await fetch(
          `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`,
          {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              contents: [
                {
                  role: 'user',
                  parts: [{ text: `${systemPrompt}\n\n${userGoalPrompt}` }],
                },
              ],
            }),
          }
        );

        console.log(`📡 ${model} API response status:`, response.status);

        // If successful or rate limited, use this model
        if (response.ok || response.status === 429) {
          usedModel = model;
          console.log(`✅ Using model: ${usedModel}`);
          break;
        }

        // If model not found or not available, try next model
        if (response.status === 404 || response.status === 400) {
          const errorText = await response.text();
          lastError = errorText;
          console.warn(`⚠️ ${model} not available (${response.status}), trying fallback...`);
          continue;
        }

        // For other errors, use this response and break
        usedModel = model;
        break;
      } catch (fetchError) {
        console.error(`❌ Error fetching ${model}:`, fetchError);
        lastError = fetchError.message;
        continue;
      }
    }

    if (!response) {
      throw new Error(`All Gemini models failed. Last error: ${lastError}`);
    }

    if (!response.ok) {
      const errorText = await response.text();
      console.error(`❌ Gemini API error: ${response.status}`, errorText);
      console.error('❌ Full error details:', {
        status: response.status,
        statusText: response.statusText,
        errorText,
        model: usedModel,
      });
      
      // Provide more helpful error messages
      let userMessage = 'AI service temporarily unavailable. Using template-based plan.';
      if (response.status === 429) {
        userMessage = 'AI API rate limit exceeded. Using template-based plan.';
      } else if (response.status === 401 || response.status === 403) {
        userMessage = 'AI API authentication failed. Using template-based plan.';
      } else if (response.status === 400) {
        userMessage = 'Invalid AI request format. Using template-based plan.';
      }
      
      throw new Error(`${userMessage} (Status: ${response.status})`);
    }

    const data = await response.json();
    console.log('AI Response data:', JSON.stringify(data, null, 2));

    if (
      !data.candidates ||
      !data.candidates[0] ||
      !data.candidates[0].content
    ) {
      console.error('Invalid AI response structure:', data);
      throw new Error('Invalid AI response structure');
    }

    const text = data.candidates[0].content.parts[0].text;
    console.log('AI Response text:', text);

    // Parse the JSON response
    const cleanedText = text.replace(/```json\n?|\n?```/g, '').trim();
    console.log('Cleaned AI text:', cleanedText);

    try {
      const planData = JSON.parse(cleanedText);
      console.log('Parsed plan data:', planData);

      // Convert the new format to the expected format
      const tasks: TaskTemplate[] = [];

      if (planData.days && Array.isArray(planData.days)) {
        for (const day of planData.days) {
          if (day.tasks && Array.isArray(day.tasks)) {
            // Check if this day is in user's preferred days
            if (preferredDays && preferredDays.length > 0) {
              // Calculate what day of the week this is (0=Sunday, 1=Monday, etc.)
              const dayOfWeek = (day.day - 1) % 7; // day.day is 1-based, so subtract 1
              if (!preferredDays.includes(dayOfWeek)) {
                console.log(`Skipping day ${day.day} (day of week ${dayOfWeek}) - not in preferred days`);
                continue; // Skip this day if it's not in preferred days
              }
            }
            
            // Limit tasks per day based on user's preferences
            const maxTasksPerDay = preferredTimeRanges && preferredTimeRanges.length > 0 ? 
              preferredTimeRanges.length : 3;
            
            const limitedTasks = day.tasks.slice(0, maxTasksPerDay);
            
            for (const task of limitedTasks) {
              // Detect HH:MM and derive a time bucket for greetings; attach custom_time
              const isHHMM =
                typeof task.time === 'string' &&
                /^\d{2}:\d{2}$/.test(task.time);
              let timeBucket:
                | 'morning'
                | 'mid_morning'
                | 'afternoon'
                | 'evening' = 'morning';
              let validTime = task.time;

              if (isHHMM) {
                const hour = parseInt(task.time.slice(0, 2), 10);
                const minute = parseInt(task.time.slice(3, 5), 10);

                // Validate and fix time if outside 07:00-23:00 window
                if (hour < 7) {
                  console.warn(
                    `⚠️ Invalid time ${task.time} - too early, adjusting to 07:00`
                  );
                  validTime = '07:00';
                } else if (hour > 23 || (hour === 23 && minute > 0)) {
                  console.warn(
                    `⚠️ Invalid time ${task.time} - too late, adjusting to 23:00`
                  );
                  validTime = '23:00';
                }

                // Recalculate hour after potential adjustment
                const adjustedHour = parseInt(validTime.slice(0, 2), 10);
                if (adjustedHour < 10) timeBucket = 'morning';
                else if (adjustedHour < 13) timeBucket = 'mid_morning';
                else if (adjustedHour < 18) timeBucket = 'afternoon';
                else timeBucket = 'evening';
              } else {
                const t = String(task.time).toLowerCase();
                if (t.includes('mid') && t.includes('morning'))
                  timeBucket = 'mid_morning';
                else if (t.includes('afternoon')) timeBucket = 'afternoon';
                else if (t.includes('evening')) timeBucket = 'evening';
                else timeBucket = 'morning';
              }

              const entry: any = {
                title: task.title,
                description: task.description,
                day_offset: day.day - 1,
                time_of_day: timeBucket,
                subtasks: task.subtasks || [],
                time_allocation_minutes: task.time_allocation_minutes || 30,
                total_subtasks: task.subtasks ? task.subtasks.length : 0,
                subtasks_completed: 0,
              };
              if (isHHMM) entry.custom_time = validTime;
              tasks.push(entry as TaskTemplate);
            }
          }
        }
      }

      console.log('Converted tasks:', tasks.length, 'tasks');

      // Validate that we got tasks from AI
      if (tasks.length === 0) {
        console.warn(`No tasks generated by AI. Falling back to template.`);
        throw new Error(`No tasks generated by AI`);
      }

      console.log(`✅ AI generated ${tasks.length} tasks successfully`);

      // Extract milestones from AI response
      let milestones = planData.milestones || [];
      const planOutline = Array.isArray(planData.plan_outline)
        ? planData.plan_outline
        : buildTailoredOutline(
            title,
            description,
            planData.category || category
          );

      // If no milestones provided, generate fallback milestones
      if (!milestones || milestones.length === 0) {
        milestones = buildTailoredMilestones(tasks.length, title, planDurationDays);
      }

      // Extract deliverables if present and minimally validate shape
      let deliverables: any = planData.deliverables || {
        overview: { chosen_topic: '', rationale: '', synopsis: '' },
        sections: [],
      };

      // Basic normalization to guarantee keys exist
      const ensure = (obj: any, key: string, fallback: any) => {
        if (obj[key] === undefined || obj[key] === null) obj[key] = fallback;
      };
      if (typeof deliverables !== 'object' || Array.isArray(deliverables)) {
        deliverables = {
          overview: { chosen_topic: '', rationale: '', synopsis: '' },
          sections: [],
        };
      }
      ensure(deliverables, 'overview', {
        chosen_topic: '',
        rationale: '',
        synopsis: '',
      });
      ensure(deliverables, 'sections', []);

      // Use the category selected by the user (no AI classification needed)
      const validCategories = [
        'lifestyle',
        'career',
        'mindset',
        'character',
        'custom',
      ] as const;
      
      let aiCategory: (typeof validCategories)[number] = category as (typeof validCategories)[number];
      if (!validCategories.includes(aiCategory)) {
        aiCategory = 'custom'; // Fallback to custom if invalid
      }

      // Map color strictly by category per mapping
      const categoryColorMap: Record<(typeof validCategories)[number], string> =
        {
          lifestyle: 'green',
          career: 'blue',
          mindset: 'purple',
          character: 'pink',
          custom: 'yellow',
        };

      // Use AI-provided icon or fallback to category default
      // Note: Icons are NOT category-specific - AI chooses based on goal content
      let iconName = 'star'; // Default fallback
      
      if (planData.icon_name) {
        // AI provided an icon - use it (icons are chosen based on goal content, not category)
        iconName = planData.icon_name;
        console.log(`🎨 Using AI suggested icon: ${iconName} (chosen based on goal content, not category: ${aiCategory})`);
      } else {
        // AI didn't provide an icon - use category fallback
        const fallbackIcons: Record<(typeof validCategories)[number], string> = {
          lifestyle: 'heart',
          career: 'briefcase',
          mindset: 'brain',
          character: 'star',
          custom: 'target',
        };
        iconName = fallbackIcons[aiCategory];
        console.log(`⚠️ AI didn't provide icon, using category fallback: ${iconName} for ${aiCategory}`);
      }

      // Choose color based on category mapping; ignore AI-provided color if any
      const color = categoryColorMap[aiCategory] || 'yellow';

      console.log(
        `🎨 AI selected icon: ${iconName}, category: ${aiCategory}, color: ${color}`
      );

      const subcategory: string | null =
        typeof planData.subcategory === 'string' ? planData.subcategory : null;
      const marketingDomain: string | null =
        typeof planData.marketing_domain === 'string'
          ? planData.marketing_domain
          : null;

      return {
        tasks,
        iconName,
        color,
        milestones,
        planOutline,
        category: aiCategory,
        subcategory,
        marketingDomain,
        deliverables,
        usedModel,
      };
    } catch (parseError) {
      console.error('Failed to parse AI response as JSON:', parseError);
      console.error('Raw text:', cleanedText);
      throw parseError;
    }
  } catch (error) {
    console.error('❌ AI generation failed, falling back to templates:', error);
    console.error('❌ Error type:', typeof error);
    console.error('❌ Error message:', error.message);
    console.error('❌ Error stack:', error.stack);
    const fallbackTasks = generateTasksForCategory(
      category,
      title,
      description,
      intensity
    );
    const fallbackMilestones = buildTailoredMilestones(
      fallbackTasks.length,
      title
    );
    const fallbackOutline = buildTailoredOutline(title, description, category);

    // Use the category selected by the user (no heuristic classification needed)
    const validCategories = [
      'lifestyle',
      'career',
      'mindset',
      'character',
      'custom',
    ] as const;
    
    let aiCategory: (typeof validCategories)[number] = category as (typeof validCategories)[number];
    if (!validCategories.includes(aiCategory)) {
      aiCategory = 'custom'; // Fallback to custom if invalid
    }

    const categoryColorMap: Record<(typeof validCategories)[number], string> = {
      lifestyle: 'green',
      career: 'blue',
      mindset: 'purple',
      character: 'pink',
      custom: 'yellow',
    };
    
    // Fallback icons (used when AI generation fails completely)
    // Note: Icons are NOT category-specific, but we use category fallback when AI fails
    const fallbackIcons: Record<(typeof validCategories)[number], string> = {
      lifestyle: 'heart',
      career: 'briefcase',
      mindset: 'brain',
      character: 'star',
      custom: 'target',
    };

    return {
      tasks: fallbackTasks,
      iconName: fallbackIcons[aiCategory],
      color: categoryColorMap[aiCategory],
      milestones: fallbackMilestones,
      category: aiCategory,
      subcategory: null,
      marketingDomain: null,
      deliverables: {
        overview: { chosen_topic: '', rationale: '', synopsis: '' },
        sections: [],
      },
      planOutline: fallbackOutline,
      usedModel: 'template-fallback',
    }; // Default icon/color; include typing fields
  }
};

// Template-based plan generation (fallback) - generates detailed daily plan based on user preferences
const generateTasksForCategory = (
  category: string,
  title: string,
  description: string,
  intensity: 'easy' | 'medium' | 'hard' = 'easy',
  planDurationDays: number = 21,
  tasksPerDayRange?: { min: number, max: number }
): TaskTemplate[] => {
  const tasks: TaskTemplate[] = [];

  // Use user's preferred task range if provided, otherwise fallback to intensity
  let tasksPerDay = 3; // Default fallback
  
  if (tasksPerDayRange) {
    // Use the average of min and max, rounded to nearest integer
    tasksPerDay = Math.round((tasksPerDayRange.min + tasksPerDayRange.max) / 2);
  } else {
    // Fallback to old intensity logic
    tasksPerDay = intensity === 'easy' ? 3 : intensity === 'medium' ? 6 : 12;
  }

  // Generate tasks per day for the specified duration
  for (let day = 0; day < planDurationDays; day++) {
    const dayNumber = day + 1;
    const weekNumber = Math.ceil(dayNumber / 7);

    // Week 1: Foundation & Awareness
    if (weekNumber === 1) {
      const dayTasks = [
        {
          title: `Day ${dayNumber}: Morning Intention Setting`,
          description: `Spend 10 minutes writing down your daily intention and how it connects to your goal. Visualize your success.`,
          day_offset: day,
          time_of_day: 'morning' as const,
        },
        {
          title: `Day ${dayNumber}: Research & Learning`,
          description: `Spend 20 minutes researching strategies and best practices for your goal. Take notes on key insights.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Progress Documentation`,
          description: `Write down what you accomplished today and how you feel about your progress. Celebrate small wins.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
        {
          title: `Day ${dayNumber}: Mid-Morning Focus`,
          description: `Take a focused 15-minute session to work on your goal. Use this time for concentrated effort.`,
          day_offset: day,
          time_of_day: 'mid_morning' as const,
        },
        {
          title: `Day ${dayNumber}: Mid-Afternoon Break`,
          description: `Take a 10-minute break to reflect on your progress and recharge for the evening session.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Evening Review`,
          description: `Review your day's accomplishments and plan tomorrow's focus areas.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
        {
          title: `Day ${dayNumber}: Early Morning Preparation`,
          description: `Set up your workspace and prepare materials for today's goal work.`,
          day_offset: day,
          time_of_day: 'morning' as const,
        },
        {
          title: `Day ${dayNumber}: Midday Check-in`,
          description: `Check your progress and adjust your approach if needed.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Late Morning Session`,
          description: `Dedicate 20 minutes to focused work on your goal.`,
          day_offset: day,
          time_of_day: 'mid_morning' as const,
        },
        {
          title: `Day ${dayNumber}: Afternoon Deep Work`,
          description: `Engage in 30 minutes of deep, uninterrupted work on your goal.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Evening Reflection`,
          description: `Spend 15 minutes reflecting on today's learnings and insights.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
        {
          title: `Day ${dayNumber}: Night Planning`,
          description: `Plan tomorrow's tasks and set intentions for continued progress.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
      ];

      // Add tasks based on intensity level
      tasks.push(...dayTasks.slice(0, tasksPerDay));
    }
    // Week 2: Skill Building & Practice
    else if (weekNumber === 2) {
      const dayTasks = [
        {
          title: `Day ${dayNumber}: Skill Development`,
          description: `Practice and develop specific skills needed for your goal. Focus on deliberate practice.`,
          day_offset: day,
          time_of_day: 'morning' as const,
        },
        {
          title: `Day ${dayNumber}: Real-world Application`,
          description: `Apply what you've learned in a real-world context. Test your skills in practical situations.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Progress Evaluation`,
          description: `Evaluate your progress and identify what's working well. Adjust your approach if needed.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
        {
          title: `Day ${dayNumber}: Advanced Practice`,
          description: `Engage in advanced practice techniques to deepen your skills.`,
          day_offset: day,
          time_of_day: 'mid_morning' as const,
        },
        {
          title: `Day ${dayNumber}: Skill Integration`,
          description: `Integrate multiple skills together in complex scenarios.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Performance Review`,
          description: `Review your performance and identify areas for improvement.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
        {
          title: `Day ${dayNumber}: Intensive Training`,
          description: `Dedicate 45 minutes to intensive skill development.`,
          day_offset: day,
          time_of_day: 'morning' as const,
        },
        {
          title: `Day ${dayNumber}: Challenge Practice`,
          description: `Challenge yourself with difficult scenarios and problems.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Skill Refinement`,
          description: `Refine and polish your existing skills to perfection.`,
          day_offset: day,
          time_of_day: 'mid_morning' as const,
        },
        {
          title: `Day ${dayNumber}: Complex Application`,
          description: `Apply your skills to complex, multi-step problems.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Mastery Assessment`,
          description: `Assess your current mastery level and set new challenges.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
        {
          title: `Day ${dayNumber}: Skill Expansion`,
          description: `Learn new related skills to expand your capabilities.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
      ];

      // Add tasks based on intensity level
      tasks.push(...dayTasks.slice(0, tasksPerDay));
    }
    // Week 3: Mastery & Integration
    else {
      const dayTasks = [
        {
          title: `Day ${dayNumber}: Advanced Practice`,
          description: `Engage in advanced practice and optimization of your skills. Push your boundaries.`,
          day_offset: day,
          time_of_day: 'morning' as const,
        },
        {
          title: `Day ${dayNumber}: Mastery Demonstration`,
          description: `Demonstrate your mastery of the skills you've developed. Show your progress.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Integration Practice`,
          description: `Integrate your new skills into your daily life and routine. Make it sustainable.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
        {
          title: `Day ${dayNumber}: Expert-Level Challenges`,
          description: `Tackle expert-level challenges to test your mastery.`,
          day_offset: day,
          time_of_day: 'mid_morning' as const,
        },
        {
          title: `Day ${dayNumber}: Teaching Others`,
          description: `Teach someone else what you've learned to solidify your understanding.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Long-term Planning`,
          description: `Plan how to maintain and continue developing your skills long-term.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
        {
          title: `Day ${dayNumber}: Peak Performance`,
          description: `Push yourself to peak performance levels in your goal area.`,
          day_offset: day,
          time_of_day: 'morning' as const,
        },
        {
          title: `Day ${dayNumber}: Innovation & Creativity`,
          description: `Apply your skills in creative and innovative ways.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Leadership Application`,
          description: `Use your skills to lead and inspire others.`,
          day_offset: day,
          time_of_day: 'mid_morning' as const,
        },
        {
          title: `Day ${dayNumber}: Excellence Standards`,
          description: `Set new excellence standards for yourself based on your growth.`,
          day_offset: day,
          time_of_day: 'afternoon' as const,
        },
        {
          title: `Day ${dayNumber}: Legacy Building`,
          description: `Consider how your skills can create lasting impact and legacy.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
        {
          title: `Day ${dayNumber}: Future Vision`,
          description: `Envision your future with these mastered skills and set new goals.`,
          day_offset: day,
          time_of_day: 'evening' as const,
        },
      ];

      // Add tasks based on intensity level
      tasks.push(...dayTasks.slice(0, tasksPerDay));
    }
  }

  return tasks;
};

const getTimeForSchedule = (
  date: Date,
  timeOfDay: 'morning' | 'mid_morning' | 'afternoon' | 'evening'
): Date => {
  const scheduledDate = new Date(date);

  switch (timeOfDay) {
    case 'morning':
      scheduledDate.setHours(8, 0, 0, 0);
      break;
    case 'mid_morning':
      scheduledDate.setHours(10, 30, 0, 0);
      break;
    case 'afternoon':
      scheduledDate.setHours(14, 0, 0, 0);
      break;
    case 'evening':
      scheduledDate.setHours(19, 0, 0, 0);
      break;
    default:
      // Fallback for old format
      scheduledDate.setHours(9, 0, 0, 0);
      break;
  }

  return scheduledDate;
};

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  // Generate request ID for tracking
  const requestId = crypto.randomUUID();
  const startTime = Date.now();

  try {
    const supabaseClient = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    // Parse and validate request
    let requestData: GeneratePlanRequest;
    try {
      requestData = await req.json();
    } catch (parseError) {
      console.error(`[${requestId}] Invalid JSON in request:`, parseError);
      return new Response(
        JSON.stringify({
          success: false,
          error: 'Invalid JSON in request body',
          request_id: requestId,
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 400,
        }
      );
    }

    const {
      user_id,
      goal_id,
      category,
      title,
      description,
      intensity = 'easy',
      timezone, // Legacy field
      start_date,
      language = 'en',
      detailed_plan = false,
      plan_duration_days = 21,
      preferred_time_ranges,
      preferred_days,
    } = requestData;

    // Validate required fields
    const requiredFields = ['user_id', 'goal_id', 'category', 'title', 'description'];
    const missingFields = requiredFields.filter(field => !requestData[field as keyof GeneratePlanRequest]);
    
    if (missingFields.length > 0) {
      console.error(`[${requestId}] Missing required fields:`, missingFields);
      return new Response(
        JSON.stringify({
          success: false,
          error: `Missing required fields: ${missingFields.join(', ')}`,
          request_id: requestId,
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 400,
        }
      );
    }

    // Handle missing device timezone fields with fallback
    let device_now_iso = requestData.device_now_iso;
    let device_timezone = requestData.device_timezone;
    let device_utc_offset_minutes = requestData.device_utc_offset_minutes;

    if (!device_now_iso || !device_timezone) {
      console.warn(`[${requestId}] Missing device timezone fields, using fallback values`);
      const now = new Date();
      device_now_iso = now.toISOString();
      device_timezone = 'UTC'; // Fallback to UTC
      device_utc_offset_minutes = 0;
      
      console.warn(`[${requestId}] Using fallback: device_now_iso=${device_now_iso}, device_timezone=${device_timezone}`);
    }

    // Validate field formats
    const validCategories = ['lifestyle', 'career', 'mindset', 'character', 'goal', 'learning', 'health', 'finance', 'social', 'fitness', 'creativity', 'custom'];
    if (!validCategories.includes(category)) {
      console.error(`[${requestId}] Invalid category:`, category);
      return new Response(
        JSON.stringify({
          success: false,
          error: `Invalid category. Must be one of: ${validCategories.join(', ')}`,
          request_id: requestId,
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 400,
        }
      );
    }

    const validIntensities = ['easy', 'medium', 'hard'];
    if (!validIntensities.includes(intensity)) {
      console.error(`[${requestId}] Invalid intensity:`, intensity);
      return new Response(
        JSON.stringify({
          success: false,
          error: `Invalid intensity. Must be one of: ${validIntensities.join(', ')}`,
          request_id: requestId,
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 400,
        }
      );
    }

    // Validate UUIDs
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    if (!uuidRegex.test(user_id)) {
      console.error(`[${requestId}] Invalid user_id format:`, user_id);
      return new Response(
        JSON.stringify({
          success: false,
          error: 'Invalid user_id format',
          request_id: requestId,
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 400,
        }
      );
    }

    if (!uuidRegex.test(goal_id)) {
      console.error(`[${requestId}] Invalid goal_id format:`, goal_id);
      return new Response(
        JSON.stringify({
          success: false,
          error: 'Invalid goal_id format',
          request_id: requestId,
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 400,
        }
      );
    }

    // Validate device timezone fields (only if provided)
    if (device_now_iso && device_timezone) {
      try {
        const deviceNow = new Date(device_now_iso);
        if (isNaN(deviceNow.getTime())) {
          console.warn(`[${requestId}] Invalid device_now_iso format, using fallback:`, device_now_iso);
          device_now_iso = new Date().toISOString();
          device_timezone = 'UTC';
        }
      } catch (timeError) {
        console.warn(`[${requestId}] Error parsing device_now_iso, using fallback:`, timeError);
        device_now_iso = new Date().toISOString();
        device_timezone = 'UTC';
      }

      // Validate IANA timezone format (basic check) - if invalid, use fallback
      const ianaTimezoneRegex = /^[A-Za-z_]+\/[A-Za-z_]+$/;
      if (!ianaTimezoneRegex.test(device_timezone)) {
        console.warn(`[${requestId}] Invalid device_timezone format, using UTC fallback:`, device_timezone);
        device_timezone = 'UTC';
      }
    }

    // Verify goal ownership
    const { data: goal, error: goalError } = await supabaseClient
      .from('goals')
      .select('id, user_id, title')
      .eq('id', goal_id)
      .eq('user_id', user_id)
      .single();

    if (goalError || !goal) {
      console.error(`[${requestId}] Goal not found or access denied:`, goalError);
      return new Response(
        JSON.stringify({
          success: false,
          error: 'Goal not found or access denied',
          request_id: requestId,
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 404,
        }
      );
    }

    console.log(`[${requestId}] Plan generation request validated:`, {
      user_id,
      goal_id,
      category,
      title: title.substring(0, 50) + '...',
      intensity,
      device_timezone,
      device_now_iso: device_now_iso.substring(0, 19) + '...',
      start_date,
    });

    // Check if this is a regeneration (goal already has tasks) or new goal creation
    const { data: existingTasks, error: checkTasksError } = await supabaseClient
      .from('goal_tasks')
      .select('id')
      .eq('goal_id', goal_id)
      .limit(1);
    
    if (checkTasksError) {
      console.error(`[${requestId}] Error checking existing tasks:`, checkTasksError);
    }
    
    // Only clean up if this is a regeneration (goal already has tasks)
    if (existingTasks && existingTasks.length > 0) {
      console.log(`[${requestId}] Regenerating plan for existing goal - cleaning up previous data...`);
      
      try {
        // Delete existing tasks, rewards, and notifications for this goal
        const { error: deleteTasksError } = await supabaseClient
          .from('goal_tasks')
          .delete()
          .eq('goal_id', goal_id);
        
        if (deleteTasksError) {
          console.error(`[${requestId}] Error deleting existing tasks:`, deleteTasksError);
          // Continue anyway - this is not critical
        }

        const { error: deleteRewardsError } = await supabaseClient
          .from('rewards')
          .delete()
          .eq('goal_id', goal_id);
        
        if (deleteRewardsError) {
          console.error(`[${requestId}] Error deleting existing rewards:`, deleteRewardsError);
          // Continue anyway - this is not critical
        }

        const { error: deleteNotificationsError } = await supabaseClient
          .from('scheduled_notifications')
          .delete()
          .eq('user_id', user_id)
          .in('type', ['task_reminder', 'milestone_reward', 'completion_reward', 'motivation']);
        
        if (deleteNotificationsError) {
          console.error(`[${requestId}] Error deleting existing notifications:`, deleteNotificationsError);
          // Continue anyway - this is not critical
        }

        console.log(`[${requestId}] Cleanup completed successfully`);
      } catch (cleanupError) {
        console.error(`[${requestId}] Error during cleanup:`, cleanupError);
        // Continue anyway - this is not critical
      }
    } else {
      console.log(`[${requestId}] Creating new plan for goal - no cleanup needed`);
    }

    // Deduct a token server-side (source of truth)
    try {
      const { data: tokenRow } = await supabaseClient
        .from('user_tokens')
        .select('*')
        .eq('user_id', user_id)
        .single();

      if (tokenRow) {
        const currentRemaining = Number(tokenRow.tokens_remaining || 0);
        const shouldDecrement = currentRemaining > 0; // consume manual tokens if present
        const updateData: any = {
          tokens_used: (tokenRow.tokens_used || 0) + 1,
          updated_at: new Date().toISOString(),
        };
        if (shouldDecrement) {
          updateData.tokens_remaining = Math.max(0, currentRemaining - 1);
        }
        await supabaseClient
          .from('user_tokens')
          .update(updateData)
          .eq('user_id', user_id);
      } else {
        await supabaseClient.from('user_tokens').insert({
          user_id,
          tokens_used: 1,
          tokens_remaining: 2,
          total_tokens: 3,
          is_subscribed: false,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString(),
        });
      }
    } catch (tokErr) {
      console.warn('⚠️ Token deduction skipped:', tokErr);
    }

    // Generate tasks using AI (with template fallback)
    let aiRunId: string | null = null;
    let taskTemplates: any[] = [];
    let iconName = 'star';
    let color = 'blue';
    let milestones: any[] = [];
    let aiCategory = category;
    let deliverables: any = { overview: { chosen_topic: '', rationale: '', synopsis: '' }, sections: [] };
    let planOutline: any[] = [];

    try {
      const aiStartTime = Date.now();
      
      const result = await generateTasksWithAI(
        category,
        title,
        description,
        intensity,
        detailed_plan,
        device_now_iso, // Pass the actual device time
        device_timezone, // Pass the actual device timezone
        plan_duration_days,
        preferred_time_ranges,
        preferred_days
      );

      const aiLatency = Date.now() - aiStartTime;

      // Record AI run with the actual model used (stored in result)
      const { data: aiRun, error: aiRunError } = await supabaseClient
        .from('ai_runs')
        .insert({
          goal_id,
          status: 'success',
          provider_model: result.usedModel || 'gemini-1.5-flash',
          attempts: 1,
          latency_ms: aiLatency,
          response_size: JSON.stringify(result).length,
        })
        .select('id')
        .single();

      if (aiRunError) {
        console.error(`[${requestId}] Error creating AI run record:`, aiRunError);
      } else {
        aiRunId = aiRun.id;
      }

      taskTemplates = result.tasks;
      iconName = result.iconName;
      color = result.color;
      milestones = result.milestones;
      aiCategory = result.category;
      deliverables = result.deliverables;
      planOutline = result.planOutline || [];

      console.log(`[${requestId}] AI generation successful: ${taskTemplates.length} tasks, ${aiLatency}ms`);

    } catch (aiError) {
      console.error(`[${requestId}] AI generation failed:`, aiError);
      
      // Update AI run with failure
      if (aiRunId) {
        await supabaseClient
          .from('ai_runs')
          .update({
            status: 'failed',
            error_text: aiError.message?.substring(0, 1000) || 'Unknown error',
          })
          .eq('id', aiRunId);
      }

      // Fallback to template generation
      console.log(`[${requestId}] Falling back to template generation...`);
      const fallbackResult = generateTasksForCategory(
        category, 
        title, 
        description, 
        intensity, 
        plan_duration_days,
        { min: 3, max: 5 } // Default fallback range
      );
      taskTemplates = fallbackResult;
      milestones = buildTailoredMilestones(fallbackResult.length, title, plan_duration_days);
      planOutline = buildTailoredOutline(title, description, category);
      
      // Use default values for fallback
      const categoryColorMap: Record<string, string> = {
        lifestyle: 'green',
        career: 'blue',
        mindset: 'purple',
        character: 'pink',
        custom: 'yellow',
      };
      color = categoryColorMap[category] || 'yellow';
    }

    console.log('📋 Generated tasks:', taskTemplates.length, 'tasks');
    console.log('🎨 Selected icon:', iconName);

    // Create scheduled tasks using device timezone-aware timing
    const tasksToInsert: any[] = [];
    const usedTimeSlots = new Map<string, Set<string>>(); // day -> Set of time slots
    let startDecision: 'today' | 'tomorrow' = 'today';
    let firstTaskScheduled = false;
    
    // Pre-allocate time slots to avoid conflicts
    const preAllocatedSlots = new Map<string, string[]>(); // day -> array of available slots
    const generateTimeSlots = (day: Date) => {
      const slots: string[] = [];
      for (let hour = 7; hour < 23; hour++) {
        for (let minute = 0; minute < 60; minute += 15) {
          slots.push(`${hour.toString().padStart(2, '0')}:${minute.toString().padStart(2, '0')}`);
        }
      }
      return slots;
    };

    for (const template of taskTemplates) {
      const dayNumber = template.day_offset + 1; // Convert back to 1-based
      
      // Use AI-provided custom_time if available, otherwise use time_of_day
      let timeOfDay = template.time_of_day;
      if (template.custom_time) {
        timeOfDay = convertHHMMToTimeOfDay(template.custom_time);
      }

      // Calculate run_at using device timezone-aware function
      const timingResult = computeRunAtDeviceAware(
        dayNumber, 
        timeOfDay, 
        device_now_iso, 
        device_timezone, 
        start_date,
        preferred_time_ranges,
        preferred_days
      );

      // Add some randomization to avoid conflicts
      const baseTime = new Date(timingResult.runAt);
      const randomOffset = Math.floor(Math.random() * 15); // 0-14 minutes
      baseTime.setMinutes(baseTime.getMinutes() + randomOffset);
      
      // Ensure we stay within 07:00-23:00 window
      if (baseTime.getHours() >= 23) {
        baseTime.setDate(baseTime.getDate() + 1);
        baseTime.setHours(7, 0, 0, 0);
      }
      if (baseTime.getHours() < 7) {
        baseTime.setHours(7, 0, 0, 0);
      }
      
      timingResult.runAt = baseTime.toISOString();
      timingResult.localRunAt = baseTime.toISOString();

      // Capture start decision from first task and apply it to all day 1 tasks
      if (!firstTaskScheduled) {
        startDecision = timingResult.startDecision;
        firstTaskScheduled = true;
        console.log(`[${requestId}] Start decision: ${startDecision} (current time: ${new Date(device_now_iso).toLocaleTimeString()})`);
      }

      // If start decision is 'tomorrow' and this is day 1, adjust the timing
      if (startDecision === 'tomorrow' && dayNumber === 1) {
        // Force all day 1 tasks to start tomorrow at 07:00 or later
        const tomorrow = new Date(device_now_iso);
        tomorrow.setDate(tomorrow.getDate() + 1);
        tomorrow.setHours(7, 0, 0, 0);
        
        // Use user's preferred time ranges if available
        let targetHour = 8; // Default fallback
        
        if (preferred_time_ranges && preferred_time_ranges.length > 0) {
          const timeRangeIndex = timeOfDay === 'morning' ? 0 : 
                                timeOfDay === 'mid_morning' ? 0 : 
                                timeOfDay === 'afternoon' ? 1 : 2;
          
          if (preferred_time_ranges[timeRangeIndex]) {
            targetHour = preferred_time_ranges[timeRangeIndex].start_hour;
          }
        } else {
          // Fallback to standard time slots
          const timeSlots = {
            morning: 8,
            mid_morning: 10,
            afternoon: 14,
            evening: 20,
          };
          targetHour = timeSlots[timeOfDay] || 8;
        }
        
        tomorrow.setHours(targetHour, 0, 0, 0);
        
        // Check if tomorrow is in user's preferred days
        if (preferred_days && preferred_days.length > 0) {
          const tomorrowDayOfWeek = tomorrow.getDay();
          if (!preferred_days.includes(tomorrowDayOfWeek)) {
            // Find the next preferred day
            let daysToAdd = 1;
            while (daysToAdd <= 7) {
              const nextDate = new Date(tomorrow);
              nextDate.setDate(nextDate.getDate() + daysToAdd);
              const nextDayOfWeek = nextDate.getDay();
              
              if (preferred_days.includes(nextDayOfWeek)) {
                tomorrow.setDate(tomorrow.getDate() + daysToAdd);
                break;
              }
              daysToAdd++;
            }
          }
        }
        
        timingResult.runAt = tomorrow.toISOString();
        timingResult.localRunAt = tomorrow.toISOString();
      }

      let runAt = timingResult.runAt;
      let localRunAt = timingResult.localRunAt;

      // Check for time conflicts and resolve them with day folding
      const scheduledTime = new Date(runAt);
      const dayKey = scheduledTime.toDateString();
      const timeSlot = `${scheduledTime.getHours().toString().padStart(2, '0')}:${scheduledTime.getMinutes().toString().padStart(2, '0')}`;

      if (!usedTimeSlots.has(dayKey)) {
        usedTimeSlots.set(dayKey, new Set());
      }

      const dayTimeSlots = usedTimeSlots.get(dayKey)!;

      // If time slot is already used, find next available slot or fold to next day
      if (dayTimeSlots.has(timeSlot)) {
        console.warn(
          `[${requestId}] Time conflict detected for "${template.title}" at ${timeSlot} on ${dayKey}, finding alternative...`
        );

        // Try to find a better time slot within the same day first
        let adjustedTime = new Date(scheduledTime);
        let attempts = 0;
        const maxAttempts = 50;

        while (attempts < maxAttempts) {
          // Try adding 15 minutes
          adjustedTime.setMinutes(adjustedTime.getMinutes() + 15);

          // If we go past 23:00, fold to next day at 07:00
          if (adjustedTime.getHours() >= 23) {
            adjustedTime.setDate(adjustedTime.getDate() + 1);
            adjustedTime.setHours(7, 0, 0, 0);
          }

          // Ensure we don't go below 07:00
          if (adjustedTime.getHours() < 7) {
            adjustedTime.setHours(7, 0, 0, 0);
          }

          const newTimeSlot = `${adjustedTime.getHours().toString().padStart(2, '0')}:${adjustedTime.getMinutes().toString().padStart(2, '0')}`;
          const newDayKey = adjustedTime.toDateString();
          
          if (!usedTimeSlots.has(newDayKey)) {
            usedTimeSlots.set(newDayKey, new Set());
          }
          
          const newDayTimeSlots = usedTimeSlots.get(newDayKey)!;
          
          if (!newDayTimeSlots.has(newTimeSlot)) {
            runAt = adjustedTime.toISOString();
            localRunAt = adjustedTime.toISOString();
            console.log(`[${requestId}] Resolved time conflict for "${template.title}" - moved to ${newTimeSlot} on ${newDayKey}`);
            break;
          }
          attempts++;
        }

        if (attempts >= maxAttempts) {
          console.error(
            `[${requestId}] Could not resolve time conflict for "${template.title}" after ${maxAttempts} attempts`
          );
          // Use original time and let database handle it
        }
      }

      // Mark this time slot as used, plus reserve time for task completion
      const finalTimeSlot = `${new Date(runAt).getHours().toString().padStart(2, '0')}:${new Date(runAt).getMinutes().toString().padStart(2, '0')}`;
      const finalDayKey = new Date(runAt).toDateString();
      const finalDayTimeSlots = usedTimeSlots.get(finalDayKey)!;
      finalDayTimeSlots.add(finalTimeSlot);
      
      // Reserve additional time slots based on task allocation
      const taskDuration = template.time_allocation_minutes || 30;
      const reservedSlots = Math.ceil(taskDuration / 15); // Reserve 15-minute slots
      const startTime = new Date(runAt);
      
      for (let i = 1; i < reservedSlots; i++) {
        const reservedTime = new Date(startTime.getTime() + (i * 15 * 60 * 1000));
        const reservedSlot = `${reservedTime.getHours().toString().padStart(2, '0')}:${reservedTime.getMinutes().toString().padStart(2, '0')}`;
        finalDayTimeSlots.add(reservedSlot);
      }

      // Final validation: ensure the task is within 07:00-23:00 window
      const finalScheduledTime = new Date(runAt);
      const finalHour = finalScheduledTime.getHours();
      
      if (finalHour < 7 || finalHour >= 23) {
        console.warn(`[${requestId}] Task "${template.title}" scheduled outside 07:00-23:00 window (${finalHour}:00), adjusting...`);
        // Adjust to nearest valid time
        if (finalHour < 7) {
          finalScheduledTime.setHours(7, 0, 0, 0);
        } else {
          finalScheduledTime.setHours(22, 0, 0, 0); // 22:00 is the latest valid time
        }
        runAt = finalScheduledTime.toISOString();
        localRunAt = finalScheduledTime.toISOString();
      }

      tasksToInsert.push({
        goal_id,
        title: template.title,
        description: template.description,
        run_at: runAt,
        local_run_at: localRunAt, // Store local time for UI display
        intensity: intensity, // Store intensity level with task
        day_offset: template.day_offset, // Store day offset for idempotency
        time_of_day: timeOfDay, // Store time of day for idempotency
        subtasks: template.subtasks || [],
        time_allocation_minutes: template.time_allocation_minutes || 30,
        total_subtasks: template.total_subtasks || 0,
        subtasks_completed: template.subtasks_completed || 0,
      });
    }

    // Insert tasks into database
    const { data: insertedTasks, error: insertError } = await supabaseClient
      .from('goal_tasks')
      .insert(tasksToInsert)
      .select();

    if (insertError) {
      throw insertError;
    }

    // Create personalized notifications for each task (dynamic based on actual tasks)
    const notificationsToInsert = insertedTasks.map((task, index) => {
      const taskTime = new Date(task.run_at);
      const taskHour = taskTime.getHours();

      const timeBasedGreetings = {
        morning: '☀️ Good morning!',
        mid_morning: '🌅 Morning task time!',
        afternoon: '🌤️ Afternoon focus!',
        evening: '🌙 Evening task!',
      };

      let timeOfDay: 'morning' | 'mid_morning' | 'afternoon' | 'evening';
      if (taskHour < 10) timeOfDay = 'morning';
      else if (taskHour < 13) timeOfDay = 'mid_morning';
      else if (taskHour < 18) timeOfDay = 'afternoon';
      else timeOfDay = 'evening';

      const motivationalPrefixes = [
        'Let\'s do this! 💪',
        'Time to shine! ✨',
        'You\'ve got this! 🚀',
        'Make it count! 🎯',
        'Keep going! 🌟',
      ];

      const prefix = motivationalPrefixes[index % motivationalPrefixes.length];

      return {
        user_id,
        goal_id,
        task_id: task.id,
        type: 'task_reminder',
        title: `${timeBasedGreetings[timeOfDay]} ${task.title}`,
        body: `${prefix}\n\n${task.description}\n\nTap to view subtasks and get started!`,
        scheduled_for: task.run_at,
      };
    });

    const { error: notificationError } = await supabaseClient
      .from('scheduled_notifications')
      .insert(notificationsToInsert);

    if (notificationError) {
      console.error('Error creating task notifications:', notificationError);
      // Don't throw here, as the main task creation succeeded
    } else {
      console.log(`✅ Created ${notificationsToInsert.length} task reminder notifications`);
    }

    // Generate rewards for the goal
    const rewards = await generateRewards(
      goal_id,
      supabaseClient,
      category,
      title,
      taskTemplates,
      intensity
    );

    // Create all notification templates (rewards, good morning/night from Genie)
    const allNotifications: any[] = [];
    
    // Good morning & good night notifications from Genie
    const deviceNow = new Date(device_now_iso);
    for (let day = 0; day < plan_duration_days; day++) {
      const dayDate = new Date(deviceNow);
      dayDate.setDate(dayDate.getDate() + day);
      
      // Check if this day is in user's preferred days
      if (preferred_days && preferred_days.length > 0) {
        const dayOfWeek = dayDate.getDay();
        if (!preferred_days.includes(dayOfWeek)) {
          continue; // Skip days not in preferred days
        }
      }
      
      // Good Morning from Genie (7:30 AM)
      const morningTime = new Date(dayDate);
      morningTime.setHours(7, 30, 0, 0);
      allNotifications.push({
        user_id,
        goal_id,
        type: 'motivation',
        title: '🌅 Good Morning from Genie!',
        body: `Ready to make progress on "${title}" today? Your tasks are waiting. Let's make it a great day! ✨`,
        scheduled_for: morningTime.toISOString(),
      });
      
      // Good Night from Genie (22:30 PM)
      const nightTime = new Date(dayDate);
      nightTime.setHours(22, 30, 0, 0);
      allNotifications.push({
        user_id,
        goal_id,
        type: 'motivation',
        title: '🌙 Good Night from Genie',
        body: `Great work today on "${title}"! Rest well and recharge for tomorrow's journey. Sweet dreams! 💫`,
        scheduled_for: nightTime.toISOString(),
      });
    }
    
    // Milestone reward notifications (weekly check-ins)
    const weeklyCheckpoints = [7, 14, 21]; // Days 7, 14, 21
    weeklyCheckpoints.forEach((day, index) => {
      if (day <= plan_duration_days) {
        const checkpointDate = new Date(deviceNow);
        checkpointDate.setDate(checkpointDate.getDate() + day);
        checkpointDate.setHours(20, 0, 0, 0); // 8 PM
        
        const weekNum = index + 1;
        allNotifications.push({
          user_id,
          goal_id,
          type: 'milestone_reward',
          title: `🎉 Week ${weekNum} Complete!`,
          body: `Amazing progress on "${title}"! Check your rewards - you've earned something special! 🏆`,
          scheduled_for: checkpointDate.toISOString(),
        });
      }
    });
    
    // Final completion reward
    const completionDate = new Date(deviceNow);
    completionDate.setDate(completionDate.getDate() + plan_duration_days);
    completionDate.setHours(21, 0, 0, 0); // 9 PM on last day
    allNotifications.push({
      user_id,
      goal_id,
      type: 'completion_reward',
      title: '🏆 Goal Achievement Unlocked!',
      body: `Congratulations! You completed "${title}"! Your transformation is complete. Check out your final rewards! 🎉✨`,
      scheduled_for: completionDate.toISOString(),
    });

    // Insert all notifications at once
    const { error: notificationsInsertError } = await supabaseClient
      .from('scheduled_notifications')
      .insert(allNotifications);
      
    if (notificationsInsertError) {
      console.error('Error creating notifications:', notificationsInsertError);
      // Don't throw here, as the main task creation succeeded
    } else {
      console.log(`✅ Created ${allNotifications.length} scheduled notifications (tasks, morning/night greetings, rewards)`);
    }

    // Update the goal with the AI-selected icon, color, and device timezone info
    await supabaseClient
      .from('goals')
      .update({ 
        icon_name: iconName, 
        color: color, 
        category: aiCategory,
        device_timezone: device_timezone,
        start_decision: startDecision
      })
      .eq('id', goal_id);

    // Note: Task notifications are scheduled, not sent immediately
    // Users will receive notifications based on scheduled_for times in scheduled_notifications table

    // Send push notification that plan is ready for approval
    try {
      const notificationResponse = await fetch(
        `${Deno.env.get('SUPABASE_URL')}/functions/v1/push-dispatcher`,
        {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            user_id,
            title: '✨ Your Plan is Ready!',
            body: `Your personalized ${plan_duration_days}-day plan for "${title}" is ready for approval. Check it out now!`,
            data: {
              type: 'plan_ready',
              goal_id,
              screen: 'NewGoal',
            },
          }),
        }
      );

      if (notificationResponse.ok) {
        console.log('✅ Plan ready notification sent successfully');
      } else {
        console.warn('⚠️ Failed to send plan ready notification');
      }
    } catch (notificationError) {
      console.error('❌ Error sending plan ready notification:', notificationError);
      // Don't fail the whole process for notification errors
    }

    const totalTime = Date.now() - startTime;
    console.log(`[${requestId}] Plan generation completed successfully in ${totalTime}ms`);

    return new Response(
      JSON.stringify({
        success: true,
        tasks: insertedTasks,
        rewards: rewards,
        icon_name: iconName,
        color: color,
        category: aiCategory,
        milestones: milestones,
        plan_outline: planOutline,
        deliverables: deliverables,
        message: `Generated ${insertedTasks.length} tasks and ${rewards.length} rewards for your goal`,
        request_id: requestId,
        processing_time_ms: totalTime,
        // Device timezone metadata
        start_decision: startDecision,
        device_timezone_used: device_timezone,
        today_window: '07:00-23:00',
        device_utc_offset_minutes: device_utc_offset_minutes,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error) {
    const totalTime = Date.now() - startTime;
    console.error(`[${requestId}] Error generating plan after ${totalTime}ms:`, error);
    
    return new Response(
      JSON.stringify({
        success: false,
        error: error.message || 'Internal server error',
        request_id: requestId,
        processing_time_ms: totalTime,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      }
    );
  }
});
